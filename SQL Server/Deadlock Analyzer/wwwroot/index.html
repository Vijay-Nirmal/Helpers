<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Server Deadlock Analyzer</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #888888;
            --accent-primary: #007acc;
            --accent-secondary: #005499;
            --border: #404040;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --info: #17a2b8;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-muted: #6c757d;
            --accent-primary: #007bff;
            --accent-secondary: #0056b3;
            --border: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--accent-primary);
            color: white;
        }

        .upload-section {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .textarea-input {
            width: 100%;
            height: 200px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 20px;
        }

        .btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .dashboard {
            display: none;
        }

        .dashboard.active {
            display: block;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 10px;
            border: 1px solid var(--border);
            text-align: center;
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--accent-primary);
            margin-bottom: 10px;
        }

        .metric-label {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.85rem;
        }

        .section {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-tertiary);
            border-radius: 5px;
            overflow: hidden;
        }

        .table th, .table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .table th {
            background: var(--accent-primary);
            color: white;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
        }

        .table th:hover {
            background: var(--accent-secondary);
        }

        .table tr:hover {
            background: var(--bg-primary);
        }

        .accordion {
            border: 1px solid var(--border);
            border-radius: 5px;
            overflow: hidden;
        }

        .accordion-item {
            border-bottom: 1px solid var(--border);
        }

        .accordion-item:last-child {
            border-bottom: none;
        }

        .accordion-header {
            background: var(--bg-tertiary);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .accordion-header:hover {
            background: var(--border);
        }

        .accordion-content {
            padding: 20px;
            display: none;
            background: var(--bg-primary);
        }

        .accordion-content.active {
            display: block;
        }

        .badge {
            background: var(--accent-primary);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .filter-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-bar input, .filter-bar select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
        }

        .modal.active {
            display: block;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 1200px;
            border: 1px solid var(--border);
            position: relative;
        }

        .modal-close {
            position: absolute;
            right: 20px;
            top: 20px;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .process-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .process-card {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .victim-card {
            border-left: 4px solid var(--danger);
        }

        .blocker-card {
            border-left: 4px solid var(--warning);
        }

        .code-block {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .suggestions {
            background: var(--bg-tertiary);
            border-left: 4px solid var(--info);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid var(--border);
            border-top: 4px solid var(--accent-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }

        .deadlock-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            min-height: 200px;
        }

        .diagram-process {
            background: var(--bg-tertiary);
            border: 2px solid var(--accent-primary);
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            text-align: center;
            min-width: 150px;
        }

        .diagram-arrow {
            font-size: 24px;
            color: var(--accent-primary);
            margin: 0 10px;
        }

        .highlight {
            background: var(--warning);
            color: var(--bg-primary);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .diagnostic-result {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
        }

        .diagnostic-result table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .diagnostic-result th,
        .diagnostic-result td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .diagnostic-result th {
            background: var(--accent-primary);
            color: white;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            margin-left: 8px;
            cursor: pointer;
            border: 1px solid var(--border);
            background: var(--accent-primary);
            color: white;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s ease;
        }

        .btn-small:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
        }

        .btn-small:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .expandable-content {
            margin-top: 10px;
            padding: 15px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .expandable-content.sql-content {
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent-primary);
        }

        .expandable-content.resource-content {
            background: var(--bg-secondary);
            border-left: 4px solid var(--success);
        }

        .expandable-content.db-content {
            background: var(--bg-secondary);
            border-left: 4px solid var(--warning);
        }

        .content-header {
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border);
        }

        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--accent-primary);
            animation: spin 1s ease-in-out infinite;
            margin-right: 5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .process-info {
                grid-template-columns: 1fr;
            }
            
            .filter-bar {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üîç SQL Server Deadlock Analyzer</h1>
            <div>
                <button class="theme-toggle" onclick="toggleTheme()">üåô Toggle Theme</button>
                <button class="btn btn-secondary" onclick="clearCache()" style="margin-left: 10px;">üóëÔ∏è Clear Cache</button>
            </div>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 20px; margin-bottom: 20px;">
                <hr style="border: 1px solid var(--border);">
                <h2 style="margin: 0;">Connect to Database</h2>
                <hr style="border: 1px solid var(--border);">
            </div>

            <div id="dbConnectionForm" style="display: grid; grid-template-columns: 1fr; gap: 15px; margin-bottom: 20px;">
                <input type="text" id="connectionStringInput" placeholder="Connection String (e.g., Server=localhost;Database=master;Integrated Security=true;)" style="background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 5px;">
                <input type="text" id="dbConnectionString" placeholder="Connection String for Enhanced Analysis (for SQL Handle, Resource, and DB Name lookups)" style="background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 5px;">
                
                <!-- Extended Event Parameters -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <input type="text" id="extendedEventSession" placeholder="Extended Event Session (default: system_health)" style="background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); padding: 8px; border-radius: 5px; font-size: 14px;">
                    <input type="datetime-local" id="startDateTime" placeholder="Start Date/Time" style="background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); padding: 8px; border-radius: 5px; font-size: 14px;">
                    <input type="datetime-local" id="endDateTime" placeholder="End Date/Time" style="background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); padding: 8px; border-radius: 5px; font-size: 14px;">
                </div>
                <input type="number" id="maxRecords" placeholder="Max Records (default: 1000)" min="1" max="10000" style="background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); padding: 8px; border-radius: 5px; font-size: 14px;">
                
                <div style="font-size: 12px; color: var(--text-muted); margin-top: -10px;">
                    üí° The enhanced analysis connection is used for the "Get Full SQL", "Get Resource Info", and "Get DB Name" buttons in detailed deadlock views.<br>
                    üîç Extended Event Session: Specify which extended event session to query (default: system_health).<br>
                    üìÖ Date Range: Optionally filter deadlocks by date/time range.
                </div>
            </div>
             <div style="text-align: center; margin-bottom: 20px;">
                <button class="btn" onclick="processDeadlocksFromDb()">üîó Connect & Analyze</button>
            </div>

            <div style="text-align: center; margin: 20px 0; color: var(--text-muted);">
                <strong>‚Äî OR ‚Äî</strong>
            </div>

            <div class="upload-area" onclick="document.getElementById('fileInput').click();">
                <input type="file" id="fileInput" accept=".xml,.xdl,.txt" onchange="handleFileUpload(event)">
                <div style="font-size: 3rem; margin-bottom: 15px;">üì§</div>
                <h3>Click to upload or drag & drop</h3>
                <p style="color: var(--text-muted); margin-top: 10px;">Supports XML, XDL, and TXT files</p>
            </div>

            <div style="text-align: center; margin: 20px 0; color: var(--text-muted);">
                <strong>‚Äî OR ‚Äî</strong>
            </div>

            <textarea class="textarea-input" id="xmlInput" placeholder="Paste your deadlock XML here..."></textarea>
            
            <div style="text-align: center;">
                <button class="btn" onclick="processDeadlocksFromFile()">üîÑ Process Deadlocks from File</button>
            </div>
        </div>

        <!-- Loading Section -->
        <div class="loading" id="loadingSection">
            <div class="spinner"></div>
            <h3>Analyzing deadlock reports...</h3>
            <p>Please wait while we process your data.</p>
        </div>

        <!-- Dashboard -->
        <div class="dashboard" id="dashboard">
            <!-- Metrics Cards -->
            <div class="metrics-grid" id="metricsGrid">
                <!-- Metrics will be populated here -->
            </div>

            <!-- Charts Section -->
            <div class="section">
                <h2 class="section-title">üìä Visual Analysis</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="chart-container">
                        <canvas id="victimChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="objectChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Export Section -->
            <div class="section">
                <h2 class="section-title">üì§ Export Data</h2>
                <button class="btn" onclick="exportToExcel()">üìä Export to Excel</button>
                <button class="btn btn-secondary" onclick="exportToJson()" style="margin-left: 10px;">üíæ Export to JSON</button>
            </div>

            <!-- Cache Status Section -->
            <div class="section" id="cacheStatusSection">
                <h2 class="section-title">üóÑÔ∏è Cache Status</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <div class="metric-card">
                        <div class="metric-value" id="sqlHandleCacheCount">0</div>
                        <div class="metric-label">SQL Handles Cached</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="databaseCacheCount">0</div>
                        <div class="metric-label">Database Names Cached</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="resourceCacheCount">0</div>
                        <div class="metric-label">Resources Cached</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="totalCacheCount">0</div>
                        <div class="metric-label">Total Cached Items</div>
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="clearAllCaches(); updateCacheStatus();">üóëÔ∏è Clear All Caches</button>
                <button class="btn btn-secondary" onclick="updateCacheStatus()" style="margin-left: 10px;">üîÑ Refresh Status</button>
            </div>

            <!-- Parsing Errors Section (if any) -->
            <div class="section" id="parsingErrorsSection" style="display: none;">
                <h2 class="section-title" style="color: var(--warning);">‚ö†Ô∏è Parsing Issues</h2>
                <div id="parsingErrorsSummary" style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <!-- Parsing errors summary will be populated here -->
                </div>
                <button class="btn btn-secondary" onclick="showParsingErrorsModal()">üîç View Parsing Errors</button>
                <button class="btn btn-secondary" onclick="downloadAllErrorReports()" style="margin-left: 10px;">üì• Download Error Reports</button>
            </div>

            <!-- Filter Bar -->
            <div class="section">
                <h2 class="section-title">üîç Filter & Search</h2>
                <div class="filter-bar">
                    <input type="text" id="processFilter" placeholder="Filter by process name..." onkeyup="applyFilters()">
                    <input type="text" id="queryFilter" placeholder="Filter by query/procedure..." onkeyup="applyFilters()">
                    <input type="text" id="hostnameFilter" placeholder="Filter by hostname..." onkeyup="applyFilters()">
                    <input type="text" id="objectFilter" placeholder="Filter by object name..." onkeyup="applyFilters()">
                    <select id="roleFilter" onchange="applyFilters()">
                        <option value="">All Roles</option>
                        <option value="victim">Victims Only</option>
                        <option value="blocker">Blockers Only</option>
                    </select>
                    <button class="btn btn-secondary" onclick="clearAllFilters()" style="margin-left: 10px;">üóëÔ∏è Clear Filters</button>
                </div>
            </div>

            <!-- Common Processes Table -->
            <div class="section">
                <h2 class="section-title">‚öôÔ∏è Common Processes</h2>
                <div class="filter-bar" style="margin-bottom: 20px;">
                    <label for="viewByFilter" style="color: var(--text-secondary); margin-right: 10px;">View by:</label>
                    <select id="viewByFilter" onchange="changeProcessView()" style="margin-right: 20px;">
                        <option value="process">Process Name</option>
                        <option value="query">Query/Procedure</option>
                        <option value="hostname">Hostname</option>
                    </select>
                    <button class="btn btn-secondary" onclick="filterBySelection()" id="filterBySelectionBtn" style="display: none;">üîç Filter by Selected</button>
                </div>
                <div style="overflow-x: auto;">
                    <table class="table" id="processesTable">
                        <thead>
                            <tr>
                                <th onclick="sortTable('processesTable', 0)" id="processTableHeader">Process Name</th>
                                <th onclick="sortTable('processesTable', 1)">Total Count</th>
                                <th onclick="sortTable('processesTable', 2)">Victim Count</th>
                                <th onclick="sortTable('processesTable', 3)">Blocker Count</th>
                                <th onclick="sortTable('processesTable', 4)">Percentage</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="processesTableBody">
                            <!-- Data will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Unique Deadlocks -->
            <div class="section">
                <h2 class="section-title">üîí Unique Deadlock Patterns</h2>
                <div class="accordion" id="uniqueDeadlocks">
                    <!-- Unique deadlocks will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Detailed Deadlock Modal -->
    <div class="modal" id="detailModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <div id="modalContent">
                <!-- Modal content will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let deadlockData = [];
        let filteredData = [];
        let processedData = {
            totalDeadlocks: 0,
            uniquePatterns: 0,
            processes: {},
            victims: {},
            objects: {},
            uniqueDeadlocks: []
        };
        
        // Chart instances for proper cleanup
        let victimChart = null;
        let objectChart = null;
        
        // Error tracking
        let parsingErrors = [];
        let rawXmlContent = '';
        
        // Cache for dynamic queries
        let sqlHandleCache = new Map();
        let databaseNameCache = new Map();
        let resourceInfoCache = new Map();
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            loadCachedData();
        });

        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        // Load theme from localStorage
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.body.setAttribute('data-theme', savedTheme);
        }
        loadTheme();

        // Setup drag and drop functionality
        function setupDragAndDrop() {
            const uploadArea = document.querySelector('.upload-area');
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }

        // File upload handler
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        // Process uploaded file
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('xmlInput').value = e.target.result;
                processDeadlocksFromFile();
            };
            reader.readAsText(file);
        }

        // Main processing function for files
        function processDeadlocksFromFile() {
            const xmlContent = document.getElementById('xmlInput').value.trim();
            if (!xmlContent) {
                alert('Please upload a file or paste XML content.');
                return;
            }
            processDeadlocks(xmlContent);
        }

        async function processDeadlocksFromDb() {
            const connectionString = document.getElementById('connectionStringInput').value.trim();
            const extendedEventSession = document.getElementById('extendedEventSession').value.trim();
            const startDateTime = document.getElementById('startDateTime').value;
            const endDateTime = document.getElementById('endDateTime').value;
            const maxRecords = document.getElementById('maxRecords').value;

            if (!connectionString) {
                alert('Please enter a connection string.');
                return;
            }

            showLoading(true);

            try {
                const requestBody = {
                    connectionString: connectionString
                };

                // Add optional parameters if provided
                if (extendedEventSession) {
                    requestBody.extendedEventSessionName = extendedEventSession;
                }
                if (startDateTime) {
                    requestBody.startDate = new Date(startDateTime).toISOString();
                }
                if (endDateTime) {
                    requestBody.endDate = new Date(endDateTime).toISOString();
                }
                if (maxRecords && parseInt(maxRecords) > 0) {
                    requestBody.maxRecords = parseInt(maxRecords);
                }

                const response = await fetch('/api/deadlock/extended-events', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to fetch deadlock reports from the database. Status: ${response.status}. ${errorText}`);
                }

                const xmlContent = await response.text();
                if (!xmlContent || xmlContent.trim() === '') {
                    const sessionName = extendedEventSession || 'system_health';
                    const dateRange = startDateTime || endDateTime ? 
                        ` for the specified date range (${startDateTime || 'start'} to ${endDateTime || 'end'})` : '';
                    throw new Error(`No deadlock reports found in the database for the "${sessionName}" session${dateRange}.`);
                }
                processDeadlocks(xmlContent);

            } catch (error) {
                console.error('Error fetching from DB:', error);
                alert(`Error: ${error.message}`);
                showLoading(false);
            }
        }


        // Main processing function
        function processDeadlocks(xmlContent) {
            if (!xmlContent) {
                alert('No XML content to process.');
                showLoading(false);
                return;
            }

            // Store raw XML content for error reporting
            rawXmlContent = xmlContent;
            parsingErrors = [];
            
            // Clear all caches when starting new analysis
            sqlHandleCache.clear();
            databaseNameCache.clear();
            resourceInfoCache.clear();
            
            showLoading(true);
            
            setTimeout(() => {
                try {
                    console.log('Starting to parse deadlock XML...');
                    parseDeadlockXML(xmlContent);
                    console.log(`Successfully parsed ${deadlockData.length} deadlock reports`);
                    
                    // Check if we have any successful parses or only errors
                    if (deadlockData.length === 0 && parsingErrors.length === 0) {
                        throw new Error('No valid deadlock reports found in the input');
                    }
                    
                    // Show parsing results (including errors if any)
                    if (parsingErrors.length > 0) {
                        showParsingErrorsModal();
                    } else {
                        // No errors, proceed normally
                        proceedWithAnalysis();
                    }
                    
                } catch (error) {
                    console.error('Error processing deadlocks:', error);
                    showDetailedErrorModal(error);
                } finally {
                    showLoading(false);
                }
            }, 100);
        }
        
        // Proceed with analysis after handling errors
        function proceedWithAnalysis() {
            if (deadlockData.length === 0) {
                alert('No successfully parsed deadlock reports to analyze.');
                return;
            }
            
            console.log('Analyzing deadlocks...');
            analyzeDeadlocks();
            console.log('Rendering dashboard...');
            renderDashboard();
            saveToCache();
            showDashboard();
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--success);
                color: white;
                padding: 15px 20px;
                border-radius: 5px;
                z-index: 1001;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            successMsg.innerHTML = `‚úÖ Successfully processed ${deadlockData.length} deadlock reports!`;
            document.body.appendChild(successMsg);
            
            setTimeout(() => {
                if (successMsg.parentNode) {
                    successMsg.parentNode.removeChild(successMsg);
                }
            }, 5000);
        }
        
        // Show parsing errors modal with options
        function showParsingErrorsModal() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 1002;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: var(--bg-secondary);
                border-radius: 10px;
                padding: 30px;
                max-width: 900px;
                max-height: 80vh;
                overflow-y: auto;
                border: 1px solid var(--border);
                position: relative;
            `;
            
            const errorSummary = parsingErrors.length === 1 ? 
                `1 deadlock report failed to parse` : 
                `${parsingErrors.length} deadlock reports failed to parse`;
            
            const successSummary = deadlockData.length === 1 ? 
                `1 deadlock report was successfully parsed` : 
                `${deadlockData.length} deadlock reports were successfully parsed`;
            
            content.innerHTML = `
                <h2 style="color: var(--warning); margin-bottom: 20px;">‚ö†Ô∏è Parsing Issues Detected</h2>
                
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <p><strong>Summary:</strong></p>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li style="color: var(--success);">‚úÖ ${successSummary}</li>
                        <li style="color: var(--danger);">‚ùå ${errorSummary}</li>
                    </ul>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <h3 style="color: var(--danger); margin-bottom: 15px;">Failed Reports:</h3>
                    <div style="max-height: 300px; overflow-y: auto; border: 1px solid var(--border); border-radius: 5px;">
                        ${parsingErrors.map((error, index) => `
                            <div style="padding: 15px; border-bottom: 1px solid var(--border); ${index === parsingErrors.length - 1 ? 'border-bottom: none;' : ''}">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                    <strong style="color: var(--danger);">Report ${error.lineNumber || index + 1}:</strong>
                                    <button class="btn btn-secondary" onclick="downloadErrorReport(${index})" style="padding: 5px 10px; font-size: 12px;">
                                        üì• Download
                                    </button>
                                </div>
                                <div style="background: var(--bg-primary); padding: 10px; border-radius: 3px; font-family: monospace; font-size: 12px; margin-bottom: 10px;">
                                    <strong>Error:</strong> ${error.message}
                                </div>
                                <details style="margin-bottom: 10px;">
                                    <summary style="cursor: pointer; color: var(--accent-primary);">View Raw XML</summary>
                                    <div style="background: var(--bg-primary); padding: 10px; border-radius: 3px; font-family: monospace; font-size: 11px; margin-top: 10px; max-height: 200px; overflow-y: auto; word-break: break-all;">
                                        ${error.rawXml.replace(/</g, '&lt;').replace(/>/g, '&gt;')}
                                    </div>
                                </details>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    ${deadlockData.length > 0 ? `
                        <button class="btn" onclick="skipErrorsAndProceed()" style="background: var(--success);">
                            ‚úÖ Continue with ${deadlockData.length} Successful Report${deadlockData.length === 1 ? '' : 's'}
                        </button>
                    ` : ''}
                    <button class="btn btn-secondary" onclick="downloadAllErrorReports()">
                        üì• Download All Failed Reports
                    </button>
                    <button class="btn btn-secondary" onclick="downloadParsingErrorLog()">
                        üìã Download Error Log
                    </button>
                    <button class="btn btn-danger" onclick="closeParsingErrorsModal()">
                        ‚ùå Cancel
                    </button>
                </div>
            `;
            
            modal.className = 'parsing-errors-modal';
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeParsingErrorsModal();
                }
            });
        }
        
        // Skip errors and proceed with successful parses
        function skipErrorsAndProceed() {
            closeParsingErrorsModal();
            proceedWithAnalysis();
        }
        
        // Close parsing errors modal
        function closeParsingErrorsModal() {
            const modal = document.querySelector('.parsing-errors-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Download individual error report
        function downloadErrorReport(errorIndex) {
            const error = parsingErrors[errorIndex];
            const content = `Deadlock Report Parsing Error
================================

Line/Report Number: ${error.lineNumber || errorIndex + 1}
Error Message: ${error.message}
Timestamp: ${new Date().toISOString()}

Raw XML Content:
${error.rawXml}

Stack Trace:
${error.stack || 'No stack trace available'}
`;
            
            downloadTextFile(content, `deadlock-error-report-${errorIndex + 1}.txt`);
        }
        
        // Download all error reports
        function downloadAllErrorReports() {
            const content = `Deadlock Reports Parsing Errors
===============================

Total Failed Reports: ${parsingErrors.length}
Total Successful Reports: ${deadlockData.length}
Analysis Date: ${new Date().toISOString()}

${parsingErrors.map((error, index) => `
Report ${error.lineNumber || index + 1} Error:
${'='.repeat(50)}
Error Message: ${error.message}
Stack Trace: ${error.stack || 'No stack trace available'}

Raw XML Content:
${error.rawXml}

${'='.repeat(50)}
`).join('\n')}
`;
            
            downloadTextFile(content, `deadlock-parsing-errors-${new Date().toISOString().split('T')[0]}.txt`);
        }
        
        // Download parsing error log
        function downloadParsingErrorLog() {
            const logData = {
                timestamp: new Date().toISOString(),
                totalReports: parsingErrors.length + deadlockData.length,
                successfulReports: deadlockData.length,
                failedReports: parsingErrors.length,
                errors: parsingErrors.map((error, index) => ({
                    reportNumber: error.lineNumber || index + 1,
                    errorMessage: error.message,
                    stackTrace: error.stack || 'No stack trace available',
                    rawXmlLength: error.rawXml.length
                }))
            };
            
            const content = JSON.stringify(logData, null, 2);
            downloadTextFile(content, `deadlock-parsing-log-${new Date().toISOString().split('T')[0]}.json`);
        }
        
        // Utility function to download text files
        function downloadTextFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // Show detailed error modal for critical errors
        function showDetailedErrorModal(error) {
            const errorMsg = `
                <div style="background: var(--danger); color: white; padding: 20px; border-radius: 5px; margin: 20px 0;">
                    <h3>‚ùå Critical Error Processing Deadlock Data</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <hr style="margin: 15px 0; border: none; border-top: 1px solid rgba(255,255,255,0.3);">
                    <h4>üí° Troubleshooting Tips:</h4>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li><strong>Line-by-line format:</strong> Each line should contain a complete deadlock XML element</li>
                        <li><strong>XML format:</strong> Ensure each line starts with &lt;deadlock&gt; and ends with &lt;/deadlock&gt;</li>
                        <li><strong>Valid XML:</strong> Check for unclosed tags or special characters that need escaping</li>
                        <li><strong>File encoding:</strong> Ensure the file is saved in UTF-8 encoding</li>
                    </ul>
                    <p><strong>Sample format:</strong> Each line should look like:<br>
                    <code style="background: rgba(0,0,0,0.3); padding: 5px; border-radius: 3px; font-size: 12px; word-break: break-all;">
                    &lt;deadlock&gt;&lt;victim-list&gt;...&lt;/victim-list&gt;&lt;process-list&gt;...&lt;/process-list&gt;&lt;resource-list&gt;...&lt;/resource-list&gt;&lt;/deadlock&gt;
                    </code></p>
                </div>
            `;
            
            // Show error in a modal
            const errorModal = document.createElement('div');
            errorModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 1002;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const errorContent = document.createElement('div');
            errorContent.style.cssText = `
                background: var(--bg-secondary);
                border-radius: 10px;
                padding: 30px;
                max-width: 800px;
                max-height: 80vh;
                overflow-y: auto;
                border: 1px solid var(--border);
                position: relative;
            `;
            
            errorContent.innerHTML = errorMsg + `
                <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="downloadRawXmlContent()">üì• Download Raw XML</button>
                    <button class="btn" onclick="this.closest('.error-modal').remove()">Close</button>
                </div>
            `;
            
            errorModal.className = 'error-modal';
            errorModal.appendChild(errorContent);
            document.body.appendChild(errorModal);
            
            // Close modal when clicking outside
            errorModal.addEventListener('click', function(e) {
                if (e.target === errorModal) {
                    errorModal.remove();
                }
            });
        }
        
        // Download raw XML content
        function downloadRawXmlContent() {
            if (rawXmlContent) {
                downloadTextFile(rawXmlContent, `raw-deadlock-data-${new Date().toISOString().split('T')[0]}.xml`);
            } else {
                alert('No raw XML content available to download.');
            }
        }

        // Parse XML content
        function parseDeadlockXML(xmlContent) {
            deadlockData = [];
            parsingErrors = [];
            
            // Determine if this is line-by-line format or formatted XML
            const isLineByLineFormat = detectLineByLineFormat(xmlContent);
            console.log(`Using parsing method: ${isLineByLineFormat ? 'Line-by-line' : 'Formatted XML'}`);
            
            if (isLineByLineFormat) {
                // Handle line-by-line format (each line is a complete deadlock XML)
                const lines = xmlContent.trim().split('\n').filter(line => line.trim().length > 0);
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.length === 0) continue;
                    
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(line, 'text/xml');
                        
                        // Check for parsing errors
                        const parseError = xmlDoc.getElementsByTagName('parsererror');
                        if (parseError.length > 0) {
                            const errorMsg = parseError[0].textContent || 'XML parsing error';
                            parsingErrors.push({
                                lineNumber: i + 1,
                                message: `XML Parse Error: ${errorMsg}`,
                                rawXml: line,
                                stack: `Line ${i + 1}: ${errorMsg}`
                            });
                            continue;
                        }
                        
                        const deadlocks = xmlDoc.getElementsByTagName('deadlock');
                        if (deadlocks.length > 0) {
                            const parsedDeadlock = parseDeadlockElement(deadlocks[0]);
                            if (parsedDeadlock) {
                                deadlockData.push(parsedDeadlock);
                            } else {
                                parsingErrors.push({
                                    lineNumber: i + 1,
                                    message: 'Failed to parse deadlock structure - missing required elements',
                                    rawXml: line,
                                    stack: `Line ${i + 1}: Deadlock structure validation failed`
                                });
                            }
                        } else {
                            // Also check for deadlock-list format
                            const deadlockLists = xmlDoc.getElementsByTagName('deadlock-list');
                            if (deadlockLists.length > 0) {
                                const deadlocksInList = deadlockLists[0].getElementsByTagName('deadlock');
                                let lineHasValidDeadlock = false;
                                for (let j = 0; j < deadlocksInList.length; j++) {
                                    const parsedDeadlock = parseDeadlockElement(deadlocksInList[j]);
                                    if (parsedDeadlock) {
                                        deadlockData.push(parsedDeadlock);
                                        lineHasValidDeadlock = true;
                                    }
                                }
                                if (!lineHasValidDeadlock) {
                                    parsingErrors.push({
                                        lineNumber: i + 1,
                                        message: 'No valid deadlock elements found in deadlock-list',
                                        rawXml: line,
                                        stack: `Line ${i + 1}: Empty or invalid deadlock-list`
                                    });
                                }
                            } else {
                                parsingErrors.push({
                                    lineNumber: i + 1,
                                    message: 'No deadlock or deadlock-list elements found',
                                    rawXml: line,
                                    stack: `Line ${i + 1}: Missing deadlock elements`
                                });
                            }
                        }
                    } catch (error) {
                        parsingErrors.push({
                            lineNumber: i + 1,
                            message: `JavaScript Error: ${error.message}`,
                            rawXml: line,
                            stack: error.stack || `Line ${i + 1}: ${error.message}`
                        });
                        continue;
                    }
                }
            } else {
                // Handle formatted XML document (single or multiple deadlocks in structured XML)
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    // Check for parsing errors
                    const parseError = xmlDoc.getElementsByTagName('parsererror');
                    if (parseError.length > 0) {
                        const errorMsg = parseError[0].textContent || 'XML parsing error';
                        parsingErrors.push({
                            lineNumber: 1,
                            message: `XML Parse Error: ${errorMsg}`,
                            rawXml: xmlContent,
                            stack: `Formatted XML: ${errorMsg}`
                        });
                        return; // Cannot continue with invalid XML
                    }
                    
                    // Look for deadlock elements (both standalone and within deadlock-list)
                    const deadlocks = xmlDoc.getElementsByTagName('deadlock');
                    
                    if (deadlocks.length === 0) {
                        parsingErrors.push({
                            lineNumber: 1,
                            message: 'No deadlock elements found in XML document',
                            rawXml: xmlContent,
                            stack: 'Formatted XML: Missing deadlock elements'
                        });
                        return;
                    }

                    for (let i = 0; i < deadlocks.length; i++) {
                        const deadlock = deadlocks[i];
                        try {
                            const parsedDeadlock = parseDeadlockElement(deadlock);
                            if (parsedDeadlock) {
                                deadlockData.push(parsedDeadlock);
                            } else {
                                parsingErrors.push({
                                    lineNumber: i + 1,
                                    message: `Failed to parse deadlock ${i + 1} - missing required elements`,
                                    rawXml: deadlock.outerHTML || xmlContent,
                                    stack: `Deadlock ${i + 1}: Structure validation failed`
                                });
                            }
                        } catch (error) {
                            parsingErrors.push({
                                lineNumber: i + 1,
                                message: `Error parsing deadlock ${i + 1}: ${error.message}`,
                                rawXml: deadlock.outerHTML || xmlContent,
                                stack: error.stack || `Deadlock ${i + 1}: ${error.message}`
                            });
                        }
                    }
                } catch (error) {
                    parsingErrors.push({
                        lineNumber: 1,
                        message: `Critical XML Error: ${error.message}`,
                        rawXml: xmlContent,
                        stack: error.stack || `Formatted XML: ${error.message}`
                    });
                }
            }
            
            // Log parsing results
            console.log(`Parsing completed: ${deadlockData.length} successful, ${parsingErrors.length} errors`);
            
            if (deadlockData.length === 0 && parsingErrors.length === 0) {
                throw new Error('No deadlock reports found in the input');
            }
        }

        // Detect if XML content is in line-by-line format or formatted XML
        function detectLineByLineFormat(xmlContent) {
            const lines = xmlContent.trim().split('\n').filter(line => line.trim().length > 0);
            
            // If only one line, it's definitely not line-by-line format in the traditional sense
            if (lines.length <= 1) {
                console.log('Detection: Single line detected, treating as formatted XML');
                return false;
            }
            
            // Check if each line appears to be a complete XML document
            // Line-by-line format characteristics:
            // 1. Each line starts with < and ends with >
            // 2. Each line contains at least one complete XML element
            // 3. Lines don't appear to be indented (formatted XML usually has indentation)
            
            let linesWithCompleteXml = 0;
            let linesWithIndentation = 0;
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                
                // Check if line has significant leading whitespace (indentation)
                const leadingWhitespace = line.length - line.trimStart().length;
                if (leadingWhitespace >= 4) { // 4+ spaces indicates formatting
                    linesWithIndentation++;
                }
                
                // Check if line looks like a complete XML document
                if (trimmedLine.startsWith('<') && trimmedLine.endsWith('>')) {
                    // Try to parse the line as XML to see if it's complete
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(trimmedLine, 'text/xml');
                        const parseError = xmlDoc.getElementsByTagName('parsererror');
                        
                        if (parseError.length === 0) {
                            // Check if it contains deadlock elements
                            const deadlocks = xmlDoc.getElementsByTagName('deadlock');
                            const deadlockLists = xmlDoc.getElementsByTagName('deadlock-list');
                            
                            if (deadlocks.length > 0 || deadlockLists.length > 0) {
                                linesWithCompleteXml++;
                            }
                        }
                    } catch (e) {
                        // Ignore parsing errors for detection
                    }
                }
            }
            
            // Decision logic:
            // - If more than 50% of lines have indentation (formatted XML)
            // - If less than 30% of lines contain complete XML (not line-by-line)
            const indentationRatio = linesWithIndentation / lines.length;
            const completeXmlRatio = linesWithCompleteXml / lines.length;
            
            console.log(`Detection stats: ${lines.length} lines, ${linesWithIndentation} indented (${(indentationRatio*100).toFixed(1)}%), ${linesWithCompleteXml} complete XML (${(completeXmlRatio*100).toFixed(1)}%)`);
            
            // If we have significant indentation, it's likely formatted XML
            if (indentationRatio > 0.5) {
                console.log('Detection: Formatted XML detected (high indentation ratio)');
                return false;
            }
            
            // If we have a good ratio of complete XML per line, it's likely line-by-line
            if (completeXmlRatio > 0.3) {
                console.log('Detection: Line-by-line format detected (high complete XML ratio)');
                return true;
            }
            
            // Default to formatted XML for ambiguous cases
            console.log('Detection: Ambiguous case, defaulting to formatted XML');
            return false;
        }

        // Parse individual deadlock element
        function parseDeadlockElement(deadlockElement) {
            try {
                const processes = {};
                const resources = {};
                let victimId = null;

                // Parse victim list - handle both formats and multiple victims
                const victimIds = new Set();
                const victimList = deadlockElement.getElementsByTagName('victim-list')[0];
                if (victimList) {
                    const victimProcesses = victimList.getElementsByTagName('victimProcess');
                    for (let v = 0; v < victimProcesses.length; v++) {
                        const victimProcessId = victimProcesses[v].getAttribute('id');
                        if (victimProcessId) {
                            victimIds.add(victimProcessId);
                        }
                    }
                    // For backwards compatibility, set victimId to the first victim
                    victimId = victimIds.size > 0 ? Array.from(victimIds)[0] : null;
                } else {
                    // Handle deadlock-list format where victim is an attribute
                    const singleVictimId = deadlockElement.getAttribute('victim');
                    if (singleVictimId) {
                        victimIds.add(singleVictimId);
                        victimId = singleVictimId;
                    }
                }

                // Parse processes
                const processList = deadlockElement.getElementsByTagName('process-list')[0];
                if (processList) {
                    const processElements = processList.getElementsByTagName('process');
                    for (let j = 0; j < processElements.length; j++) {
                        const proc = processElements[j];
                        const processId = proc.getAttribute('id');
                        
                        if (!processId) {
                            console.warn('Process element missing id attribute');
                            continue;
                        }
                        
                        processes[processId] = {
                            id: processId,
                            spid: proc.getAttribute('spid'),
                            isVictim: victimIds.has(processId),
                            taskpriority: proc.getAttribute('taskpriority'),
                            logused: proc.getAttribute('logused'),
                            waitresource: proc.getAttribute('waitresource'),
                            waittime: proc.getAttribute('waittime'),
                            ownerId: proc.getAttribute('ownerId'),
                            transactionname: proc.getAttribute('transactionname'),
                            lasttranstarted: proc.getAttribute('lasttranstarted'),
                            lockMode: proc.getAttribute('lockMode'),
                            status: proc.getAttribute('status'),
                            isolationlevel: proc.getAttribute('isolationlevel'),
                            clientapp: proc.getAttribute('clientapp'),
                            hostname: proc.getAttribute('hostname'),
                            loginname: proc.getAttribute('loginname'),
                            currentdb: proc.getAttribute('currentdb'),
                            databaseid: proc.getAttribute('currentdb'), // Database ID for lookups
                            executionStack: parseExecutionStack(proc),
                            inputBuffer: parseInputBuffer(proc)
                        };
                    }
                } else {
                    // Handle direct process elements (some formats don't have process-list wrapper)
                    const processElements = deadlockElement.getElementsByTagName('process');
                    for (let j = 0; j < processElements.length; j++) {
                        const proc = processElements[j];
                        const processId = proc.getAttribute('id');
                        
                        if (!processId) {
                            console.warn('Process element missing id attribute');
                            continue;
                        }
                        
                        processes[processId] = {
                            id: processId,
                            spid: proc.getAttribute('spid'),
                            isVictim: victimIds.has(processId),
                            taskpriority: proc.getAttribute('taskpriority'),
                            logused: proc.getAttribute('logused'),
                            waitresource: proc.getAttribute('waitresource'),
                            waittime: proc.getAttribute('waittime'),
                            ownerId: proc.getAttribute('ownerId'),
                            transactionname: proc.getAttribute('transactionname'),
                            lasttranstarted: proc.getAttribute('lasttranstarted'),
                            lockMode: proc.getAttribute('lockMode'),
                            status: proc.getAttribute('status'),
                            isolationlevel: proc.getAttribute('isolationlevel'),
                            clientapp: proc.getAttribute('clientapp'),
                            hostname: proc.getAttribute('hostname'),
                            loginname: proc.getAttribute('loginname'),
                            currentdb: proc.getAttribute('currentdb'),
                            databaseid: proc.getAttribute('currentdb'), // Database ID for lookups
                            executionStack: parseExecutionStack(proc),
                            inputBuffer: parseInputBuffer(proc)
                        };
                    }
                }

                // Validate that we have at least one process
                if (Object.keys(processes).length === 0) {
                    throw new Error('No valid processes found in deadlock');
                }

                // Parse resources
                const resourceList = deadlockElement.getElementsByTagName('resource-list')[0];
                if (resourceList) {
                    // Handle key locks
                    const keyLocks = resourceList.getElementsByTagName('keylock');
                    for (let k = 0; k < keyLocks.length; k++) {
                        const lock = keyLocks[k];
                        const lockId = lock.getAttribute('id');
                        
                        resources[lockId] = {
                            id: lockId,
                            type: 'keylock',
                            hobtid: lock.getAttribute('hobtid'),
                            dbid: lock.getAttribute('dbid'),
                            objectname: lock.getAttribute('objectname'),
                            indexname: lock.getAttribute('indexname'),
                            mode: lock.getAttribute('mode'),
                            owners: parseLockOwners(lock),
                            waiters: parseLockWaiters(lock)
                        };
                    }
                    
                    // Handle object locks
                    const objectLocks = resourceList.getElementsByTagName('objectlock');
                    for (let k = 0; k < objectLocks.length; k++) {
                        const lock = objectLocks[k];
                        const lockId = lock.getAttribute('id');
                        
                        resources[lockId] = {
                            id: lockId,
                            type: 'objectlock',
                            objid: lock.getAttribute('objid'),
                            dbid: lock.getAttribute('dbid'),
                            objectname: lock.getAttribute('objectname'),
                            subresource: lock.getAttribute('subresource'),
                            mode: lock.getAttribute('mode'),
                            lockPartition: lock.getAttribute('lockPartition'),
                            owners: parseLockOwners(lock),
                            waiters: parseLockWaiters(lock)
                        };
                    }
                }

                // Determine victims and blockers
                const victims = Object.values(processes).filter(p => p.isVictim);
                const blockers = Object.values(processes).filter(p => !p.isVictim);
                
                // For backwards compatibility, set victim to the first victim if available
                const victim = victims.length > 0 ? victims[0] : null;

                // Validate that we have essential data
                if (victims.length === 0 && blockers.length === 0) {
                    throw new Error('No victim or blocker processes identified');
                }

                return {
                    id: Date.now() + Math.random(),
                    timestamp: new Date().toISOString(),
                    processes,
                    resources,
                    victimId,
                    victim,
                    victims, // Array of all victims
                    blockers,
                    originalXml: new XMLSerializer().serializeToString(deadlockElement)
                };
            } catch (error) {
                console.warn('Error parsing deadlock element:', error);
                // Return null instead of throwing to allow the caller to handle the error
                return null;
            }
        }

        // Parse execution stack from process
        function parseExecutionStack(processElement) {
            const stack = [];
            const executionStack = processElement.getElementsByTagName('executionStack')[0];
            if (executionStack) {
                const frames = executionStack.getElementsByTagName('frame');
                for (let i = 0; i < frames.length; i++) {
                    const frame = frames[i];
                    stack.push({
                        procname: frame.getAttribute('procname'),
                        line: frame.getAttribute('line'),
                        stmtstart: frame.getAttribute('stmtstart'),
                        stmtend: frame.getAttribute('stmtend'),
                        sqlhandle: frame.getAttribute('sqlhandle'),
                        statement: frame.textContent.trim()
                    });
                }
            }
            return stack;
        }

        // Parse input buffer from process
        function parseInputBuffer(processElement) {
            const inputBuf = processElement.getElementsByTagName('inputbuf')[0];
            return inputBuf ? inputBuf.textContent.trim() : '';
        }

        // Parse lock owners
        function parseLockOwners(lockElement) {
            const owners = [];
            const ownerList = lockElement.getElementsByTagName('owner-list')[0];
            if (ownerList) {
                const ownerElements = ownerList.getElementsByTagName('owner');
                for (let i = 0; i < ownerElements.length; i++) {
                    const owner = ownerElements[i];
                    owners.push({
                        id: owner.getAttribute('id'),
                        mode: owner.getAttribute('mode')
                    });
                }
            }
            return owners;
        }

        // Parse lock waiters
        function parseLockWaiters(lockElement) {
            const waiters = [];
            const waiterList = lockElement.getElementsByTagName('waiter-list')[0];
            if (waiterList) {
                const waiterElements = waiterList.getElementsByTagName('waiter');
                for (let i = 0; i < waiterElements.length; i++) {
                    const waiter = waiterElements[i];
                    waiters.push({
                        id: waiter.getAttribute('id'),
                        mode: waiter.getAttribute('mode'),
                        requestType: waiter.getAttribute('requestType')
                    });
                }
            }
            return waiters;
        }

        // Analyze deadlock data
        function analyzeDeadlocks() {
            processedData = {
                totalDeadlocks: deadlockData.length,
                uniquePatterns: 0,
                processes: {},
                queries: {},
                hostnames: {},
                victims: {},
                objects: {},
                uniqueDeadlocks: []
            };

            const uniqueSignatures = new Set();

            deadlockData.forEach(deadlock => {
                // Process victims and processes - handle multiple victims
                const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
                
                allVictims.forEach(victim => {
                    if (victim) {
                        const victimName = getProcessName(victim);
                        const queryName = getQueryName(victim);
                        const hostname = getHostname(victim);
                        
                        processedData.victims[victimName] = (processedData.victims[victimName] || 0) + 1;
                        
                        // Process name data
                        if (!processedData.processes[victimName]) {
                            processedData.processes[victimName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.processes[victimName].total++;
                        processedData.processes[victimName].victim++;
                        
                        // Query data
                        if (!processedData.queries[queryName]) {
                            processedData.queries[queryName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.queries[queryName].total++;
                        processedData.queries[queryName].victim++;
                        
                        // Hostname data
                        if (!processedData.hostnames[hostname]) {
                            processedData.hostnames[hostname] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.hostnames[hostname].total++;
                        processedData.hostnames[hostname].victim++;
                    }
                });

                // Process blockers
                if (deadlock.blockers && deadlock.blockers.length > 0) {
                    deadlock.blockers.forEach(blocker => {
                        const blockerName = getProcessName(blocker);
                        const queryName = getQueryName(blocker);
                        const hostname = getHostname(blocker);
                        
                        // Process name data
                        if (!processedData.processes[blockerName]) {
                            processedData.processes[blockerName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.processes[blockerName].total++;
                        processedData.processes[blockerName].blocker++;
                        
                        // Query data
                        if (!processedData.queries[queryName]) {
                            processedData.queries[queryName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.queries[queryName].total++;
                        processedData.queries[queryName].blocker++;
                        
                        // Hostname data
                        if (!processedData.hostnames[hostname]) {
                            processedData.hostnames[hostname] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.hostnames[hostname].total++;
                        processedData.hostnames[hostname].blocker++;
                    });
                }

                // Process objects
                if (deadlock.resources) {
                    Object.values(deadlock.resources).forEach(resource => {
                        if (resource.objectname) {
                            processedData.objects[resource.objectname] = (processedData.objects[resource.objectname] || 0) + 1;
                        }
                    });
                }

                // Create unique signature
                const signature = createDeadlockSignature(deadlock);
                if (!uniqueSignatures.has(signature.key)) {
                    uniqueSignatures.add(signature.key);
                    processedData.uniqueDeadlocks.push({
                        signature: signature.display,
                        key: signature.key,
                        count: 1,
                        deadlocks: [deadlock]
                    });
                } else {
                    const existing = processedData.uniqueDeadlocks.find(u => u.key === signature.key);
                    if (existing) {
                        existing.count++;
                        existing.deadlocks.push(deadlock);
                    }
                }
            });

            processedData.uniquePatterns = processedData.uniqueDeadlocks.length;
            filteredData = [...deadlockData];
        }

        // Get process name for display
        function getProcessName(process) {
            if (!process) return 'Unknown';
            
            if (process.executionStack && process.executionStack.length > 0) {
                const frame = process.executionStack[0];
                if (frame.procname && frame.procname !== 'adhoc') {
                    return frame.procname;
                }
            }
            
            if (process.clientapp) {
                return process.clientapp;
            }
            
            return `SPID ${process.spid || 'Unknown'}`;
        }

        // Get query/procedure name for display
        function getQueryName(process) {
            if (!process) return 'Unknown';
            
            if (process.executionStack && process.executionStack.length > 0) {
                const frame = process.executionStack[0];
                if (frame.procname && frame.procname !== 'adhoc') {
                    return frame.procname;
                }
                // For ad-hoc queries, try to extract meaningful part of the statement
                if (frame.statement) {
                    let stmt = frame.statement.trim();
                    // Remove extra whitespace and newlines
                    stmt = stmt.replace(/\s+/g, ' ');
                    // Truncate long statements
                    if (stmt.length > 100) {
                        stmt = stmt.substring(0, 100) + '...';
                    }
                    return stmt || 'Ad-hoc Query';
                }
            }
            
            if (process.inputBuffer) {
                let buffer = process.inputBuffer.trim();
                buffer = buffer.replace(/\s+/g, ' ');
                if (buffer.length > 100) {
                    buffer = buffer.substring(0, 100) + '...';
                }
                return buffer || 'Unknown Query';
            }
            
            return 'Unknown Query';
        }

        // Get hostname for display
        function getHostname(process) {
            if (!process) return 'Unknown';
            return process.hostname || 'Unknown';
        }

        // Create unique deadlock signature
        function createDeadlockSignature(deadlock) {
            // Handle multiple victims
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const victimNames = allVictims.map(v => getProcessName(v)).join(', ');
            const victimLines = allVictims.map(v => 
                v && v.executionStack && v.executionStack.length > 0 ? v.executionStack[0].line : '0'
            ).join(', ');
            
            const blockerNames = deadlock.blockers ? deadlock.blockers.map(b => getProcessName(b)).join(', ') : 'None';
            const blockerLines = deadlock.blockers ? deadlock.blockers.map(b => 
                b.executionStack && b.executionStack.length > 0 ? b.executionStack[0].line : '0'
            ).join(', ') : '0';

            const key = `${victimNames}:${victimLines}|${blockerNames}:${blockerLines}`;
            const display = `[VICTIMS: ${victimNames} (Lines ${victimLines})] vs [BLOCKERS: ${blockerNames} (Lines ${blockerLines})]`;

            return { key, display };
        }

        // Render dashboard
        function renderDashboard() {
            renderMetrics();
            renderProcessesTable();
            renderUniqueDeadlocks();
            renderCharts();
            renderParsingErrorsSection();
            updateCacheStatus();
        }

        // Render metrics cards
        function renderMetrics() {
            const metricsGrid = document.getElementById('metricsGrid');
            const mostFrequentVictim = Object.keys(processedData.victims).reduce((a, b) => 
                processedData.victims[a] > processedData.victims[b] ? a : b, Object.keys(processedData.victims)[0] || 'None');
            
            const processesWithBlockers = Object.keys(processedData.processes)
                .filter(p => processedData.processes[p].blocker > 0);
            const mostFrequentBlocker = processesWithBlockers.length > 0 
                ? processesWithBlockers.reduce((a, b) => processedData.processes[a].blocker > processedData.processes[b].blocker ? a : b)
                : 'None';

            metricsGrid.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${processedData.totalDeadlocks}</div>
                    <div class="metric-label">Total Deadlocks</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${processedData.uniquePatterns}</div>
                    <div class="metric-label">Unique Patterns</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${mostFrequentVictim}</div>
                    <div class="metric-label">Most Frequent Victim</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${mostFrequentBlocker}</div>
                    <div class="metric-label">Most Frequent Blocker</div>
                </div>
            `;
        }

        // Render processes table
        // Render processes table
        function renderProcessesTable() {
            const tbody = document.getElementById('processesTableBody');
            const header = document.getElementById('processTableHeader');
            const viewBy = document.getElementById('viewByFilter').value;
            const totalDeadlocks = processedData.totalDeadlocks;
            
            let dataSource, headerText;
            switch(viewBy) {
                case 'query':
                    dataSource = processedData.queries;
                    headerText = 'Query/Procedure';
                    break;
                case 'hostname':
                    dataSource = processedData.hostnames;
                    headerText = 'Hostname';
                    break;
                default:
                    dataSource = processedData.processes;
                    headerText = 'Process Name';
            }
            
            header.textContent = headerText;
            
            const sortedData = Object.entries(dataSource)
                .sort(([,a], [,b]) => b.total - a.total);

            tbody.innerHTML = sortedData.map(([name, data]) => `
                <tr>
                    <td title="${name}">${name.length > 80 ? name.substring(0, 80) + '...' : name}</td>
                    <td>${data.total}</td>
                    <td>${data.victim}</td>
                    <td>${data.blocker}</td>
                    <td>${((data.total / totalDeadlocks) * 100).toFixed(1)}%</td>
                    <td>
                        <button class="btn btn-secondary" onclick="setFilterValue('${viewBy}', '${name.replace(/'/g, "\\'")}')">üîç Filter</button>
                    </td>
                </tr>
            `).join('');
        }

        // Render unique deadlocks accordion
        function renderUniqueDeadlocks() {
            const container = document.getElementById('uniqueDeadlocks');
            
            const sortedDeadlocks = processedData.uniqueDeadlocks
                .sort((a, b) => b.count - a.count);

            container.innerHTML = sortedDeadlocks.map((pattern, index) => `
                <div class="accordion-item">
                    <div class="accordion-header" onclick="toggleAccordion(${index})">
                        <span>${pattern.signature}</span>
                        <span class="badge">${pattern.count}</span>
                    </div>
                    <div class="accordion-content" id="accordion-${index}">
                        <h4>Individual Deadlock Reports (${pattern.count})</h4>
                        ${pattern.deadlocks.map((deadlock, i) => {
                            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
                            const victimInfo = allVictims.map(v => `${getProcessName(v)} (SPID: ${v ? v.spid : 'N/A'})`).join(', ');
                            const blockerInfo = deadlock.blockers ? deadlock.blockers.map(b => `${getProcessName(b)} (SPID: ${b.spid})`).join(', ') : 'None';
                            
                            return `
                            <div style="background: var(--bg-tertiary); padding: 15px; margin: 10px 0; border-radius: 5px; cursor: pointer;" onclick="showDeadlockDetail('${pattern.key}', ${i})">
                                <strong>Report #${i + 1}</strong> - 
                                Victims: ${victimInfo} |
                                Blockers: ${blockerInfo}
                            </div>
                        `;
                        }).join('')}
                    </div>
                </div>
            `).join('');
        }

        // Toggle accordion
        function toggleAccordion(index) {
            const content = document.getElementById(`accordion-${index}`);
            if (content) {
                content.classList.toggle('active');
            }
        }

        // Show detailed deadlock view
        function showDeadlockDetail(patternKey, deadlockIndex) {
            const pattern = processedData.uniqueDeadlocks.find(p => p.key === patternKey);
            if (!pattern || !pattern.deadlocks[deadlockIndex]) return;

            const deadlock = pattern.deadlocks[deadlockIndex];
            const modalContent = document.getElementById('modalContent');
            
            // Store current deadlock XML for the XML view
            currentDeadlockXml = deadlock.originalXml || '';
            
            // Handle multiple victims
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const hasBlockers = deadlock.blockers && deadlock.blockers.length > 0;

            modalContent.innerHTML = `
                <h2>üîç Detailed Deadlock Analysis</h2>
                
                <!-- Process Information -->
                <div class="process-info">
                    <div class="process-card victim-card">
                        <h3>üéØ Victim Process${allVictims.length > 1 ? 'es' : ''}</h3>
                        ${allVictims.map(victim => renderProcessDetails(victim, true)).join('<hr style="margin: 15px 0;">')}
                    </div>
                    <div class="process-card blocker-card">
                        <h3>üö´ Blocker Process${hasBlockers && deadlock.blockers.length > 1 ? 'es' : ''}</h3>
                        ${hasBlockers ? deadlock.blockers.map(blocker => renderProcessDetails(blocker, false)).join('<hr style="margin: 15px 0;">') : '<p>No clear blocker processes identified</p>'}
                    </div>
                </div>

                <!-- Deadlock Diagram -->
                <div class="section">
                    <h3>üìä Deadlock Visualization</h3>
                    ${renderDeadlockDiagram(deadlock)}
                </div>

                <!-- Resource Information -->
                <div class="section">
                    <h3>üîí Locked Resources</h3>
                    ${renderResourceDetails(deadlock.resources)}
                </div>

                <!-- XML View -->
                <div class="section">
                    <h3>üìÑ Raw XML Data</h3>
                    <div style="margin-bottom: 10px;">
                        <button class="btn btn-secondary" onclick="toggleXmlView()">üìã Toggle XML View</button>
                        <button class="btn btn-secondary" onclick="copyXmlToClipboard()" style="margin-left: 10px;">üìã Copy XML</button>
                    </div>
                    <div id="xmlViewContainer" style="display: none;">
                        <pre class="code-block" id="xmlContent" style="max-height: 400px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; font-size: 11px;"></pre>
                    </div>
                </div>

                <!-- Fix Suggestions -->
                <div class="section">
                    <h3>üí° Fix Suggestions</h3>
                    ${renderFixSuggestions(deadlock)}
                </div>
            `;

            document.getElementById('detailModal').classList.add('active');
        }

        // Render process details
        function renderProcessDetails(process, isVictim) {
            if (!process) return '<p>No process information available</p>';

            const resourceId = `resource-${process.spid}-${Math.random().toString(36).substr(2, 9)}`;

            return `
                <p><strong>SPID:</strong> ${process.spid}</p>
                <p><strong>Application:</strong> ${process.clientapp || 'Unknown'}</p>
                <p><strong>Host:</strong> ${process.hostname || 'Unknown'}</p>
                <p><strong>Login:</strong> ${process.loginname || 'Unknown'}</p>
                <p><strong>Database ID:</strong> ${process.databaseid || 'Unknown'} 
                    ${process.databaseid ? `<button class="btn-small" onclick="getDatabaseName('${process.databaseid}', 'db-${process.spid}-${process.databaseid}')">üîç Get DB Name</button>
                    <div id="db-${process.spid}-${process.databaseid}" class="expandable-content db-content" style="display: none;"></div>` : ''}
                </p>
                <p><strong>Isolation Level:</strong> ${process.isolationlevel || 'Unknown'}</p>
                <p><strong>Transaction:</strong> ${process.transactionname || 'Unknown'}</p>
                <p><strong>Wait Resource:</strong> ${process.waitresource || 'None'} 
                    ${process.waitresource ? `<button class="btn-small" onclick="getResourceInfo('${process.waitresource}', '${resourceId}', '${process.databaseid || ''}')">üîç Get Resource Info</button>
                    <div id="${resourceId}" class="expandable-content resource-content" style="display: none;"></div>` : ''}
                </p>
                <p><strong>Lock Mode:</strong> ${process.lockMode || 'Unknown'}</p>
                
                <h4>Execution Stack:</h4>
                ${process.executionStack.map((frame, index) => `
                    <div class="code-block">
                        <strong>Procedure:</strong> ${frame.procname} 
                        ${frame.sqlhandle ? `<button class="btn-small" onclick="getSqlFromHandle('${frame.sqlhandle}', 'sql-${process.spid}-${index}', ${frame.stmtstart || 0}, ${frame.stmtend || -1})">üîç Get Full SQL</button>` : ''}
                        <br>
                        <strong>Line:</strong> <span class="highlight">${frame.line}</span><br>
                        <strong>Statement:</strong> ${frame.statement}
                        ${frame.sqlhandle ? `<div id="sql-${process.spid}-${index}" class="expandable-content sql-content" style="display: none;"></div>` : ''}
                    </div>
                `).join('')}
                
                <h4>Input Buffer:</h4>
                <div class="code-block">${process.inputBuffer || 'No input buffer available'}</div>
            `;
        }

        // Render deadlock diagram
        function renderDeadlockDiagram(deadlock) {
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const hasBlockers = deadlock.blockers && deadlock.blockers.length > 0;
            
            const victimDisplay = allVictims.length > 0 
                ? allVictims.map(v => `${getProcessName(v)}<br><small>SPID: ${v ? v.spid : 'N/A'}</small>`).join('<br>')
                : 'Unknown';
                
            const victimSpids = allVictims.length > 0
                ? allVictims.map(v => v ? v.spid : 'N/A').join(', ')
                : 'N/A';
                
            const blockerDisplay = hasBlockers 
                ? deadlock.blockers.map(b => `${getProcessName(b)}<br><small>SPID: ${b.spid}</small>`).join('<br>')
                : 'None';
                
            const blockerSpids = hasBlockers
                ? deadlock.blockers.map(b => b.spid).join(', ')
                : 'N/A';

            return `
                <div class="deadlock-diagram">
                    <div class="diagram-process">
                        <strong>Victim${allVictims.length > 1 ? 's' : ''}</strong><br>
                        ${victimDisplay}
                    </div>
                    <div class="diagram-arrow">‚áÑ</div>
                    <div style="text-align: center;">
                        <strong>Resource Contention</strong><br>
                        <small>Lock Cycle Detected</small>
                    </div>
                    <div class="diagram-arrow">‚áÑ</div>
                    <div class="diagram-process">
                        <strong>Blocker${hasBlockers && deadlock.blockers.length > 1 ? 's' : ''}</strong><br>
                        ${blockerDisplay}
                    </div>
                </div>
            `;
        }

        // Render resource details
        function renderResourceDetails(resources) {
            return Object.values(resources).map(resource => `
                <div style="background: var(--bg-tertiary); padding: 15px; margin: 10px 0; border-radius: 5px;">
                    <p><strong>Object:</strong> ${resource.objectname || 'Unknown'}</p>
                    <p><strong>Index:</strong> ${resource.indexname || 'Unknown'}</p>
                    <p><strong>Lock Type:</strong> ${resource.type}</p>
                    <p><strong>Lock Mode:</strong> ${resource.mode}</p>
                    <p><strong>Database ID:</strong> ${resource.dbid}</p>
                    <p><strong>Hobt ID:</strong> ${resource.hobtid}</p>
                </div>
            `).join('');
        }

        // Render diagnostic queries
        function renderDiagnosticQueries(deadlock) {
            const queries = [];
            let queryIndex = 0;
            
            // SQL Handle queries
            if (deadlock.victim && deadlock.victim.executionStack.length > 0) {
                const sqlHandle = deadlock.victim.executionStack[0].sqlhandle;
                if (sqlHandle) {
                    const query = `SELECT 
    text,
    statement_start_offset,
    statement_end_offset
FROM sys.dm_exec_sql_text(${sqlHandle});`;
                    
                    queries.push(`
                        <h4>Get Full Query Text (Victim):</h4>
                        <div class="code-block" id="query-${queryIndex}">${query}</div>
                        <button class="btn btn-secondary" onclick="executeDiagnosticQuery('${query.replace(/'/g, "\\'").replace(/\n/g, '\\n')}', ${queryIndex})" style="margin-top: 10px;">‚ñ∂Ô∏è Execute Query</button>
                        <div id="result-${queryIndex}" class="diagnostic-result" style="display: none; margin-top: 10px;"></div>
                    `);
                    queryIndex++;
                }
            }

            // Resource queries
            Object.values(deadlock.resources).forEach(resource => {
                if (resource.hobtid) {
                    const query = `SELECT 
    o.name AS table_name,
    i.name AS index_name,
    i.type_desc
FROM sys.partitions p
JOIN sys.objects o ON p.object_id = o.object_id
JOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id
WHERE p.hobt_id = ${resource.hobtid};`;

                    queries.push(`
                        <h4>Find Object/Index for Hobt ID ${resource.hobtid}:</h4>
                        <div class="code-block" id="query-${queryIndex}">${query}</div>
                        <button class="btn btn-secondary" onclick="executeDiagnosticQuery('${query.replace(/'/g, "\\'").replace(/\n/g, '\\n')}', ${queryIndex})" style="margin-top: 10px;">‚ñ∂Ô∏è Execute Query</button>
                        <div id="result-${queryIndex}" class="diagnostic-result" style="display: none; margin-top: 10px;"></div>
                    `);
                    queryIndex++;
                }
            });

            return queries.length > 0 ? queries.join('') : '<p>No diagnostic queries available</p>';
        }

        // Render fix suggestions
        function renderFixSuggestions(deadlock) {
            const suggestions = [];
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const hasBlockers = deadlock.blockers && deadlock.blockers.length > 0;

            // Analyze deadlock pattern and provide suggestions
            if (allVictims.length > 0) {
                suggestions.push(`
                    <div class="suggestions">
                        <h4>üîß General Recommendations:</h4>
                        <ul>
                            <li>Keep transactions as short as possible</li>
                            <li>Access objects in the same order in all procedures</li>
                            <li>Use the lowest possible isolation level</li>
                            <li>Consider using WITH (NOLOCK) for read operations where data consistency is not critical</li>
                            ${allVictims.length > 1 ? '<li><strong>Multiple Victims Detected:</strong> This indicates a complex deadlock scenario - consider implementing retry logic</li>' : ''}
                        </ul>
                    </div>
                `);

                // Check for common patterns
                const victimResources = allVictims.map(v => v ? v.waitresource : '').filter(r => r);
                const hasKeyLocks = victimResources.some(r => r.includes('KEY:'));
                const hasObjectLocks = victimResources.some(r => r.includes('OBJECT:'));
                
                if (hasKeyLocks) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>üéØ Key Lock Deadlock:</h4>
                            <ul>
                                <li>Consider using WITH (ROWLOCK) hint to prevent lock escalation</li>
                                <li>Review index fragmentation and consider rebuilding if > 30%</li>
                                <li>Use covering indexes to reduce key lookups</li>
                            </ul>
                        </div>
                    `);
                }
                
                if (hasObjectLocks) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>üè¢ Object Lock Deadlock:</h4>
                            <ul>
                                <li>This type of deadlock often involves table-level locks</li>
                                <li>Consider breaking large transactions into smaller ones</li>
                                <li>Review the use of TABLOCK and HOLDLOCK hints</li>
                                <li>Implement proper transaction ordering across all applications</li>
                            </ul>
                        </div>
                    `);
                }

                // Check for read-then-update pattern if we have victims and blockers
                if (hasBlockers && allVictims.some(v => v && v.lockMode === 'S') && deadlock.blockers.some(b => b.lockMode === 'X')) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>üìñ Read-Then-Update Deadlock:</h4>
                            <ul>
                                <li>Use WITH (UPDLOCK) on the initial SELECT to prevent this pattern</li>
                                <li>Consider using MERGE statement instead of separate SELECT/UPDATE</li>
                                <li>Implement retry logic with exponential backoff</li>
                            </ul>
                        </div>
                    `);
                }
                
                if (allVictims.length > 1) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>‚ö†Ô∏è Multi-Victim Deadlock:</h4>
                            <ul>
                                <li>This is a complex deadlock involving ${allVictims.length} victim processes</li>
                                <li>Implement comprehensive retry logic with exponential backoff</li>
                                <li>Consider using snapshot isolation level if applicable</li>
                                <li>Review application architecture for potential redesign</li>
                                <li>Monitor for escalation patterns - this may indicate systemic issues</li>
                            </ul>
                        </div>
                    `);
                }
            }

            return suggestions.length > 0 ? suggestions.join('') : '<p>No specific suggestions available</p>';
        }

        // Get SQL text from SQL handle with caching
        async function getSqlFromHandle(sqlHandle, targetId, stmtStart = 0, stmtEnd = -1) {
            const button = event.target;
            const targetDiv = document.getElementById(targetId);
            
            // Show loading state
            button.disabled = true;
            button.innerHTML = '<span class="loading-spinner"></span>Getting SQL...';
            
            try {
                // Check cache first
                const cacheKey = `${sqlHandle}_${stmtStart}_${stmtEnd}`;
                if (sqlHandleCache.has(cacheKey)) {
                    const cachedResult = sqlHandleCache.get(cacheKey);
                    const fullSqlText = typeof cachedResult === 'string' ? cachedResult : cachedResult.fullSql;
                    const statementSqlText = typeof cachedResult === 'string' ? cachedResult : cachedResult.statementSql;
                    
                    // Format SQL with line numbers and highlighting
                    const formattedSql = formatSqlWithLineNumbers(fullSqlText, stmtStart, stmtEnd);
                    
                    targetDiv.innerHTML = `
                        <div class="content-header">üìÑ Full SQL Statement (Cached)</div>
                        <div style="background: var(--bg-primary); padding: 15px; border-radius: 5px; font-family: 'Consolas', 'Courier New', monospace; font-size: 13px; line-height: 1.4; overflow-x: auto; border: 1px solid var(--border);">
                            <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">${formattedSql}</pre>
                        </div>
                        ${stmtStart !== 0 || stmtEnd !== -1 ? `
                            <div style="margin-top: 10px; padding: 10px; background: var(--bg-tertiary); border-radius: 5px; font-size: 12px; color: var(--text-secondary);">
                                <strong>Deadlock Statement Range:</strong> Characters ${stmtStart} to ${stmtEnd === -1 ? 'end' : stmtEnd}
                                ${stmtEnd !== -1 ? `<br><strong>Extracted Statement:</strong><br><code style="background: var(--bg-primary); padding: 5px; border-radius: 3px; display: block; margin-top: 5px; white-space: pre-wrap;">${statementSqlText}</code>` : ''}
                            </div>
                        ` : ''}
                    `;
                    targetDiv.style.display = 'block';
                    button.innerHTML = '‚úÖ Cached';
                    button.disabled = false;
                    return;
                }
                
                // Build the query
                const query = stmtEnd === -1 
                    ? `SELECT text FROM sys.dm_exec_sql_text(${sqlHandle})`
                    : `SELECT 
                        text,
                        CASE 
                            WHEN ${stmtStart} >= 0 AND ${stmtEnd} > ${stmtStart}
                            THEN SUBSTRING(text, (${stmtStart}/2) + 1, ((${stmtEnd} - ${stmtStart})/2) + 1)
                            ELSE text
                        END AS statement_text
                    FROM sys.dm_exec_sql_text(${sqlHandle})`;
                
                const result = await executeDiagnosticQueryInternal(query);
                
                if (result.success && result.results && result.results.length > 0) {
                    const fullSqlText = result.results[0].text;
                    const statementSqlText = stmtEnd === -1 ? fullSqlText : (result.results[0].statement_text || fullSqlText);
                    
                    // Cache the result
                    sqlHandleCache.set(cacheKey, { fullSql: fullSqlText, statementSql: statementSqlText });
                    updateCacheStatus();
                    
                    // Format SQL with line numbers and highlighting
                    const formattedSql = formatSqlWithLineNumbers(fullSqlText, stmtStart, stmtEnd);
                    
                    targetDiv.innerHTML = `
                        <div class="content-header">üìÑ Full SQL Statement</div>
                        <div style="background: var(--bg-primary); padding: 15px; border-radius: 5px; font-family: 'Consolas', 'Courier New', monospace; font-size: 13px; line-height: 1.4; overflow-x: auto; border: 1px solid var(--border);">
                            <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">${formattedSql}</pre>
                        </div>
                        ${stmtStart !== 0 || stmtEnd !== -1 ? `
                            <div style="margin-top: 10px; padding: 10px; background: var(--bg-tertiary); border-radius: 5px; font-size: 12px; color: var(--text-secondary);">
                                <strong>Deadlock Statement Range:</strong> Characters ${stmtStart} to ${stmtEnd === -1 ? 'end' : stmtEnd}
                                ${stmtEnd !== -1 ? `<br><strong>Extracted Statement:</strong><br><code style="background: var(--bg-primary); padding: 5px; border-radius: 3px; display: block; margin-top: 5px; white-space: pre-wrap;">${statementSqlText}</code>` : ''}
                            </div>
                        ` : ''}
                    `;
                    targetDiv.style.display = 'block';
                    button.innerHTML = '‚úÖ Retrieved';
                } else {
                    targetDiv.innerHTML = `
                        <div class="content-header">‚ùå Error</div>
                        <div>Failed to retrieve SQL text: ${result.message || 'Unknown error'}</div>
                    `;
                    targetDiv.style.display = 'block';
                    button.innerHTML = '‚ùå Failed';
                }
            } catch (error) {
                targetDiv.innerHTML = `
                    <div class="content-header">‚ùå Error</div>
                    <div>Error: ${error.message}</div>
                `;
                targetDiv.style.display = 'block';
                button.innerHTML = '‚ùå Error';
            }
            
            button.disabled = false;
        }

        // Get resource information with caching
        async function getResourceInfo(waitResource, targetId, databaseId = '') {
            const button = event.target;
            const targetDiv = document.getElementById(targetId);
            
            // Show loading state
            button.disabled = true;
            button.innerHTML = '<span class="loading-spinner"></span>Getting Info...';
            
            try {
                // Check cache first
                if (resourceInfoCache.has(waitResource)) {
                    const cachedResult = resourceInfoCache.get(waitResource);
                    targetDiv.innerHTML = cachedResult;
                    targetDiv.style.display = 'block';
                    button.innerHTML = '‚úÖ Cached';
                    button.disabled = false;
                    return;
                }
                
                let query = '';
                let dataQuery = '';
                let resourceType = 'Unknown';
                
                if (waitResource.includes('KEY:')) {
                    // Parse key lock format: KEY: db_id:hobt_id (hash_value)
                    const keyMatch = waitResource.match(/KEY:\s*(\d+):(\d+)\s*\(([^)]+)\)/);
                    if (keyMatch) {
                        const [, dbId, hobtId, hashValue] = keyMatch;
                        resourceType = 'Key Lock';
                        query = `
                        SELECT 
                            DB_NAME(${dbId}) AS database_name,
                            o.name AS table_name,
                            i.name AS index_name,
                            i.type_desc AS index_type,
                            p.partition_number,
                            p.rows AS partition_rows,
                            '${hashValue}' AS hash_value,
                            SCHEMA_NAME(o.schema_id) AS schema_name,
                            o.object_id,
                            i.index_id
                        FROM sys.partitions p
                        JOIN sys.objects o ON p.object_id = o.object_id
                        JOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id
                        WHERE p.hobt_id = ${hobtId}`;
                        
                        // Query to get actual locked data from the table using lockres
                        dataQuery = `
                        DECLARE @TableName NVARCHAR(256), @SchemaName NVARCHAR(256), @IndexName NVARCHAR(256), @IndexType NVARCHAR(50)
                        DECLARE @FullTableName NVARCHAR(512), @SQL NVARCHAR(MAX), @HashValue NVARCHAR(50)
                        
                        SELECT 
                            @TableName = o.name,
                            @SchemaName = SCHEMA_NAME(o.schema_id),
                            @IndexName = i.name,
                            @IndexType = i.type_desc
                        FROM sys.partitions p
                        JOIN sys.objects o ON p.object_id = o.object_id
                        JOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id
                        WHERE p.hobt_id = ${hobtId}
                        
                        SET @FullTableName = QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                        SET @HashValue = '(${hashValue})'
                        
                        -- Get the actual locked records using %%lockres%%
                        SET @SQL = 'SELECT *, %%lockres%% AS LockResource FROM ' + @FullTableName + ' WITH (NOLOCK) WHERE %%lockres%% = ''' + @HashValue + ''''
                        
                        EXEC sp_executesql @SQL`;
                    }
                } else if (waitResource.includes('PAGE:')) {
                    // Parse page lock format: PAGE: db_id:file_id:page_id
                    const pageMatch = waitResource.match(/PAGE:\s*(\d+):(\d+):(\d+)/);
                    if (pageMatch) {
                        const [, dbId, fileId, pageId] = pageMatch;
                        resourceType = 'Page Lock';
                        query = `
                        SELECT 
                            DB_NAME(${dbId}) AS database_name,
                            '${fileId}' AS file_id,
                            '${pageId}' AS page_id,
                            CASE 
                                WHEN ${pageId} = 0 THEN 'File Header Page'
                                WHEN ${pageId} = 1 THEN 'Page Free Space (PFS) Page'
                                WHEN ${pageId} % 511232 = 0 THEN 'Global Allocation Map (GAM) Page'
                                WHEN ${pageId} % 511232 = 1 THEN 'Shared Global Allocation Map (SGAM) Page'
                                ELSE 'Data/Index Page'
                            END AS page_type
                        `;
                        
                        // Try to find the object that owns this page
                        query += `
                        UNION ALL
                        SELECT 
                            DB_NAME(${dbId}) AS database_name,
                            '${fileId}' AS file_id,
                            '${pageId}' AS page_id,
                            'Object: ' + o.name + ' (Index: ' + ISNULL(i.name, 'Heap') + ')' AS page_type
                        FROM sys.allocation_units au
                        JOIN sys.partitions p ON au.container_id = p.partition_id
                        JOIN sys.objects o ON p.object_id = o.object_id
                        LEFT JOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id
                        WHERE au.first_page <= ${pageId} AND au.last_page >= ${pageId}
                        `;
                        
                        // Query to get actual locked data from the page using physloc
                        dataQuery = `
                        DECLARE @TableName NVARCHAR(256), @SchemaName NVARCHAR(256), @IndexName NVARCHAR(256)
                        DECLARE @FullTableName NVARCHAR(512), @SQL NVARCHAR(MAX), @PageFilter NVARCHAR(50)
                        
                        SELECT TOP 1
                            @TableName = o.name,
                            @SchemaName = SCHEMA_NAME(o.schema_id),
                            @IndexName = ISNULL(i.name, 'Heap')
                        FROM sys.allocation_units au
                        JOIN sys.partitions p ON au.container_id = p.partition_id
                        JOIN sys.objects o ON p.object_id = o.object_id
                        LEFT JOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id
                        WHERE au.first_page <= ${pageId} AND au.last_page >= ${pageId}
                        
                        IF @TableName IS NOT NULL
                        BEGIN
                            SET @FullTableName = QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                            SET @PageFilter = '(${fileId}:${pageId}%'
                            
                            -- Get the actual locked records on this page using sys.fn_PhysLocFormatter
                            SET @SQL = 'SELECT sys.fn_PhysLocFormatter(%%physloc%%) AS PhysicalLocation, * FROM ' + @FullTableName + ' WITH (NOLOCK) WHERE sys.fn_PhysLocFormatter(%%physloc%%) LIKE ''' + @PageFilter + ''''
                            
                            EXEC sp_executesql @SQL
                        END`;
                    }
                } else if (waitResource.includes('OBJECT:')) {
                    // Parse object lock format: OBJECT: db_id:object_id
                    const objectMatch = waitResource.match(/OBJECT:\s*(\d+):(\d+)/);
                    if (objectMatch) {
                        const [, dbId, objectId] = objectMatch;
                        resourceType = 'Object Lock';
                        query = `
                        SELECT 
                            DB_NAME(${dbId}) AS database_name,
                            o.name AS object_name,
                            o.type_desc AS object_type,
                            SCHEMA_NAME(o.schema_id) AS schema_name,
                            o.create_date,
                            o.modify_date
                        FROM sys.objects o
                        WHERE o.object_id = ${objectId}`;
                        
                        // Query to get sample data from the object if it's a table (table locks get sample data)
                        dataQuery = `
                        DECLARE @TableName NVARCHAR(256), @SchemaName NVARCHAR(256), @ObjectType NVARCHAR(50)
                        DECLARE @FullTableName NVARCHAR(512), @SQL NVARCHAR(MAX)
                        
                        SELECT 
                            @TableName = o.name,
                            @SchemaName = SCHEMA_NAME(o.schema_id),
                            @ObjectType = o.type_desc
                        FROM sys.objects o
                        WHERE o.object_id = ${objectId}
                        
                        IF @ObjectType IN ('USER_TABLE', 'VIEW')
                        BEGIN
                            SET @FullTableName = QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                            
                            -- For table locks, get sample records from the table (top 20 for performance)
                            SET @SQL = 'SELECT TOP 20 * FROM ' + @FullTableName + ' WITH (NOLOCK)'
                            
                            EXEC sp_executesql @SQL
                        END`;
                    }
                } else if (waitResource.includes('RID:')) {
                    // Parse RID lock format: RID: db_id:file_id:page_id:slot_id
                    const ridMatch = waitResource.match(/RID:\s*(\d+):(\d+):(\d+):(\d+)/);
                    if (ridMatch) {
                        const [, dbId, fileId, pageId, slotId] = ridMatch;
                        resourceType = 'Row Lock (RID)';
                        query = `
                        SELECT 
                            DB_NAME(${dbId}) AS database_name,
                            '${fileId}' AS file_id,
                            '${pageId}' AS page_id,
                            '${slotId}' AS slot_id,
                            'Row identifier lock' AS lock_description
                        `;
                        
                        // Query to get the actual row data using physloc for RID locks
                        dataQuery = `
                        DECLARE @TableName NVARCHAR(256), @SchemaName NVARCHAR(256)
                        DECLARE @FullTableName NVARCHAR(512), @SQL NVARCHAR(MAX), @RidFilter NVARCHAR(50)
                        
                        SELECT TOP 1
                            @TableName = o.name,
                            @SchemaName = SCHEMA_NAME(o.schema_id)
                        FROM sys.allocation_units au
                        JOIN sys.partitions p ON au.container_id = p.partition_id
                        JOIN sys.objects o ON p.object_id = o.object_id
                        WHERE au.first_page <= ${pageId} AND au.last_page >= ${pageId}
                        
                        IF @TableName IS NOT NULL
                        BEGIN
                            SET @FullTableName = QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName)
                            SET @RidFilter = '(${fileId}:${pageId}:${slotId})'
                            
                            -- Get the actual locked row using sys.fn_PhysLocFormatter
                            SET @SQL = 'SELECT sys.fn_PhysLocFormatter(%%physloc%%) AS PhysicalLocation, * FROM ' + @FullTableName + ' WITH (NOLOCK) WHERE sys.fn_PhysLocFormatter(%%physloc%%) = ''' + @RidFilter + ''''
                            
                            EXEC sp_executesql @SQL
                        END`;
                    }
                }
                
                if (query) {
                    const result = await executeDiagnosticQueryInternal(query);
                    
                    let content = `<div class="content-header">üîç ${resourceType} Information</div>`;
                    
                    if (result.success && result.results && result.results.length > 0) {
                        content += '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
                        
                        // Add header
                        const headers = Object.keys(result.results[0]);
                        content += '<tr>' + headers.map(h => `<th style="border: 1px solid var(--border); padding: 8px; background: var(--bg-secondary);">${h}</th>`).join('') + '</tr>';
                        
                        // Add data rows
                        result.results.forEach(row => {
                            content += '<tr>' + headers.map(h => `<td style="border: 1px solid var(--border); padding: 8px;">${row[h] || 'NULL'}</td>`).join('') + '</tr>';
                        });
                        
                        content += '</table>';
                    } else {
                        content += `<div>No information found for resource: ${waitResource}</div>`;
                    }
                    
                    // Execute data query if available and resource is KEY, PAGE, or OBJECT lock
                    if (dataQuery && (waitResource.includes('KEY:') || waitResource.includes('PAGE:') || waitResource.includes('OBJECT:') || waitResource.includes('RID:'))) {
                        try {
                            const dataResult = await executeDiagnosticQueryInternal(dataQuery);
                            
                            if (dataResult.success && dataResult.results && dataResult.results.length > 0) {
                                // Determine the type of data retrieved based on lock type
                                let dataHeader = '';
                                let dataDescription = '';
                                
                                if (waitResource.includes('KEY:')) {
                                    dataHeader = 'üîë Actual Locked Records (Key Lock)';
                                    dataDescription = 'Records matching the hash value using %%lockres%% filter';
                                } else if (waitResource.includes('PAGE:')) {
                                    dataHeader = 'üìÑ Records on Locked Page';
                                    dataDescription = 'Records on the specific page using sys.fn_PhysLocFormatter(%%physloc%%) filter';
                                } else if (waitResource.includes('RID:')) {
                                    dataHeader = 'üìç Exact Locked Row (RID)';
                                    dataDescription = 'The specific row using sys.fn_PhysLocFormatter(%%physloc%%) filter';
                                } else if (waitResource.includes('OBJECT:')) {
                                    dataHeader = 'üìä Sample Records from Table (Object Lock)';
                                    dataDescription = 'Sample records from the locked table (top 20 with NOLOCK hint for performance)';
                                }
                                
                                content += `<div class="content-header" style="margin-top: 20px;">${dataHeader}</div>`;
                                content += `<div style="margin-bottom: 10px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 12px; color: var(--text-secondary);">${dataDescription}</div>`;
                                content += '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
                                
                                // Add header for data table
                                const dataHeaders = Object.keys(dataResult.results[0]);
                                content += '<tr>' + dataHeaders.map(h => `<th style="border: 1px solid var(--border); padding: 8px; background: var(--bg-secondary); font-size: 12px;">${h}</th>`).join('') + '</tr>';
                                
                                // Add data rows (limit to prevent overwhelming display)
                                const maxRows = waitResource.includes('OBJECT:') ? 20 : 50; // More rows for object locks (sample data), fewer for specific locks
                                dataResult.results.slice(0, maxRows).forEach(row => {
                                    content += '<tr>' + dataHeaders.map(h => {
                                        let cellValue = row[h];
                                        if (cellValue === null) cellValue = 'NULL';
                                        else if (typeof cellValue === 'string' && cellValue.length > 100) {
                                            cellValue = cellValue.substring(0, 100) + '...';
                                        }
                                        return `<td style="border: 1px solid var(--border); padding: 6px; font-size: 11px; max-width: 200px; overflow: hidden; text-overflow: ellipsis;">${cellValue}</td>`;
                                    }).join('') + '</tr>';
                                });
                                
                                content += '</table>';
                                
                                // Add count information
                                if (dataResult.results.length > 0) {
                                    content += `<div style="margin-top: 10px; padding: 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 12px; color: var(--text-secondary);">
                                        <strong>Found ${dataResult.results.length} record${dataResult.results.length === 1 ? '' : 's'}</strong>
                                        ${waitResource.includes('KEY:') ? ' - These are the exact records that were locked during the deadlock' : ''}
                                        ${waitResource.includes('PAGE:') ? ' - These are all records on the locked page' : ''}
                                        ${waitResource.includes('RID:') ? ' - This is the exact row that was locked' : ''}
                                        ${waitResource.includes('OBJECT:') ? ' - Sample of records from the locked table' : ''}
                                    </div>`;
                                }
                            } else {
                                content += `<div style="margin-top: 20px; padding: 10px; background: var(--bg-tertiary); border-radius: 4px;">
                                    <strong>Note:</strong> Could not retrieve sample records from the table. This might be due to:
                                    <ul style="margin: 5px 0 0 20px;">
                                        <li>Table doesn't exist or is not accessible</li>
                                        <li>Insufficient permissions</li>
                                        <li>System table or special object type</li>
                                    </ul>
                                </div>`;
                            }
                        } catch (dataError) {
                            content += `<div style="margin-top: 20px; padding: 10px; background: var(--bg-tertiary); border-radius: 4px;">
                                <strong>Note:</strong> Could not retrieve sample records: ${dataError.message}
                            </div>`;
                        }
                    }
                    
                    // Cache the result
                    resourceInfoCache.set(waitResource, content);
                    updateCacheStatus();
                    
                    targetDiv.innerHTML = content;
                } else {
                    targetDiv.innerHTML = `
                        <div class="content-header">‚ùì Unknown Resource Type</div>
                        <div>Cannot parse resource format: ${waitResource}</div>
                    `;
                }
                
                targetDiv.style.display = 'block';
                button.innerHTML = '‚úÖ Retrieved';
                
            } catch (error) {
                targetDiv.innerHTML = `
                    <div class="content-header">‚ùå Error</div>
                    <div>Error: ${error.message}</div>
                `;
                targetDiv.style.display = 'block';
                button.innerHTML = '‚ùå Error';
            }
            
            button.disabled = false;
        }

        // Get database name with caching
        async function getDatabaseName(databaseId, targetId) {
            const button = event.target;
            const targetDiv = document.getElementById(targetId);
            
            // Show loading state
            button.disabled = true;
            button.innerHTML = '<span class="loading-spinner"></span>Getting Name...';
            
            try {
                // Check cache first
                if (databaseNameCache.has(databaseId)) {
                    const cachedName = databaseNameCache.get(databaseId);
                    targetDiv.innerHTML = `
                        <div class="content-header">üóÑÔ∏è Database Information (Cached)</div>
                        <div><strong>Database Name:</strong> ${cachedName}</div>
                        <div><strong>Database ID:</strong> ${databaseId}</div>
                    `;
                    targetDiv.style.display = 'block';
                    button.innerHTML = '‚úÖ Cached';
                    button.disabled = false;
                    return;
                }
                
                const query = `SELECT DB_NAME(${databaseId}) AS database_name`;
                const result = await executeDiagnosticQueryInternal(query);
                
                if (result.success && result.results && result.results.length > 0) {
                    const dbName = result.results[0].database_name;
                    
                    // Cache the result
                    databaseNameCache.set(databaseId, dbName);
                    updateCacheStatus();
                    
                    targetDiv.innerHTML = `
                        <div class="content-header">üóÑÔ∏è Database Information</div>
                        <div><strong>Database Name:</strong> ${dbName || 'Unknown'}</div>
                        <div><strong>Database ID:</strong> ${databaseId}</div>
                    `;
                    targetDiv.style.display = 'block';
                    button.innerHTML = '‚úÖ Retrieved';
                } else {
                    targetDiv.innerHTML = `
                        <div class="content-header">‚ùå Error</div>
                        <div>Failed to retrieve database name for ID: ${databaseId}</div>
                    `;
                    targetDiv.style.display = 'block';
                    button.innerHTML = '‚ùå Failed';
                }
            } catch (error) {
                targetDiv.innerHTML = `
                    <div class="content-header">‚ùå Error</div>
                    <div>Error: ${error.message}</div>
                `;
                targetDiv.style.display = 'block';
                button.innerHTML = '‚ùå Error';
            }
            
            button.disabled = false;
        }

        // Internal function to execute diagnostic queries without UI updates
        async function executeDiagnosticQueryInternal(query) {
            const connectionString = document.getElementById('dbConnectionString')?.value;
            if (!connectionString) {
                throw new Error('Please set a database connection string in the database connection section');
            }
            
            const response = await fetch('/api/deadlock/execute-diagnostic-query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    connectionString: connectionString,
                    query: query
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return await response.json();
        }

        // Render charts
        function renderCharts() {
            // Destroy existing charts if they exist
            if (victimChart) {
                victimChart.destroy();
                victimChart = null;
            }
            if (objectChart) {
                objectChart.destroy();
                objectChart = null;
            }
            
            renderVictimChart();
            renderObjectChart();
        }

        // Render victim distribution chart
        function renderVictimChart() {
            const ctx = document.getElementById('victimChart').getContext('2d');
            const victims = Object.entries(processedData.victims)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);

            victimChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: victims.map(([name]) => name),
                    datasets: [{
                        data: victims.map(([, count]) => count),
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
                            '#9966FF', '#FF9F40', '#FF6384', '#36A2EB',
                            '#FFCE56', '#4BC0C0'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top Victim Processes',
                            color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                        },
                        legend: {
                            labels: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            }
                        }
                    }
                }
            });
        }

        // Render object distribution chart
        function renderObjectChart() {
            const ctx = document.getElementById('objectChart').getContext('2d');
            const objects = Object.entries(processedData.objects)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);

            objectChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: objects.map(([name]) => name.split('.').pop()),
                    datasets: [{
                        label: 'Deadlock Count',
                        data: objects.map(([, count]) => count),
                        backgroundColor: '#36A2EB'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top Affected Objects',
                            color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                        },
                        legend: {
                            labels: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            }
                        }
                    },
                    scales: {
                        y: {
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            },
                            grid: {
                                color: getComputedStyle(document.body).getPropertyValue('--border')
                            }
                        },
                        x: {
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            },
                            grid: {
                                color: getComputedStyle(document.body).getPropertyValue('--border')
                            }
                        }
                    }
                }
            });
        }

        // Render parsing errors section
        function renderParsingErrorsSection() {
            const section = document.getElementById('parsingErrorsSection');
            const summary = document.getElementById('parsingErrorsSummary');
            
            if (parsingErrors && parsingErrors.length > 0) {
                section.style.display = 'block';
                summary.innerHTML = `
                    <p><strong>Parsing Results:</strong></p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                        <div>
                            <span style="color: var(--success); font-weight: bold;">‚úÖ Successfully Parsed:</span>
                            <span style="font-size: 1.2em; margin-left: 10px;">${deadlockData.length} report${deadlockData.length === 1 ? '' : 's'}</span>
                        </div>
                        <div>
                            <span style="color: var(--danger); font-weight: bold;">‚ùå Failed to Parse:</span>
                            <span style="font-size: 1.2em; margin-left: 10px;">${parsingErrors.length} report${parsingErrors.length === 1 ? '' : 's'}</span>
                        </div>
                    </div>
                    <p style="margin-top: 15px; color: var(--text-secondary);">
                        <strong>Note:</strong> Analysis is based on successfully parsed reports only. 
                        Review failed reports to ensure no critical deadlock information is missing.
                    </p>
                `;
            } else {
                section.style.display = 'none';
            }
        }

        // Apply filters
        // Apply filters
        function applyFilters() {
            const processFilter = document.getElementById('processFilter').value.toLowerCase();
            const queryFilter = document.getElementById('queryFilter').value.toLowerCase();
            const hostnameFilter = document.getElementById('hostnameFilter').value.toLowerCase();
            const objectFilter = document.getElementById('objectFilter').value.toLowerCase();
            const roleFilter = document.getElementById('roleFilter').value;

            // Check if any filters are active
            const hasActiveFilters = processFilter || queryFilter || hostnameFilter || objectFilter || roleFilter;

            filteredData = deadlockData.filter(deadlock => {
                let matches = true;

                // Process name filter
                if (processFilter) {
                    const allProcesses = [...(deadlock.victims || []), ...(deadlock.blockers || [])];
                    const processNames = allProcesses.map(p => getProcessName(p).toLowerCase()).join(' ');
                    matches = matches && processNames.includes(processFilter);
                }

                // Query/procedure filter
                if (queryFilter) {
                    const allProcesses = [...(deadlock.victims || []), ...(deadlock.blockers || [])];
                    const queryNames = allProcesses.map(p => getQueryName(p).toLowerCase()).join(' ');
                    matches = matches && queryNames.includes(queryFilter);
                }

                // Hostname filter
                if (hostnameFilter) {
                    const allProcesses = [...(deadlock.victims || []), ...(deadlock.blockers || [])];
                    const hostnames = allProcesses.map(p => getHostname(p).toLowerCase()).join(' ');
                    matches = matches && hostnames.includes(hostnameFilter);
                }

                // Object filter
                if (objectFilter) {
                    const objectNames = Object.values(deadlock.resources || {})
                        .map(r => (r.objectname || '').toLowerCase())
                        .join(' ');
                    matches = matches && objectNames.includes(objectFilter);
                }

                // Role filter
                if (roleFilter) {
                    if (roleFilter === 'victim' && (!deadlock.victims || deadlock.victims.length === 0)) {
                        matches = false;
                    }
                    if (roleFilter === 'blocker' && (!deadlock.blockers || deadlock.blockers.length === 0)) {
                        matches = false;
                    }
                }

                return matches;
            });

            // Re-analyze and re-render data (either filtered or all data if no filters)
            if (hasActiveFilters && filteredData.length !== deadlockData.length) {
                // Apply filters - temporarily replace deadlockData with filtered data
                const originalData = deadlockData;
                deadlockData = filteredData;
                analyzeDeadlocks();
                renderDashboard();
                deadlockData = originalData;
            } else if (!hasActiveFilters) {
                // No filters active - show all data
                filteredData = [...deadlockData];
                analyzeDeadlocks();
                renderDashboard();
            }
        }

        // Sort table
        function sortTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                const aVal = a.cells[columnIndex].textContent.trim();
                const bVal = b.cells[columnIndex].textContent.trim();

                // Check if values are numeric
                const aNum = parseFloat(aVal.replace(/[^\d.-]/g, ''));
                const bNum = parseFloat(bVal.replace(/[^\d.-]/g, ''));

                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return bNum - aNum; // Descending for numbers
                } else {
                    return aVal.localeCompare(bVal); // Ascending for text
                }
            });

            rows.forEach(row => tbody.appendChild(row));
        }

        // Export to Excel
        function exportToExcel() {
            const wb = XLSX.utils.book_new();



            // Summary sheet
            const summaryData = [
                ['Total Deadlocks', processedData.totalDeadlocks],
                ['Unique Patterns', processedData.uniquePatterns],
                ['Analysis Date', new Date().toISOString()]
            ];
            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');

            // Processes sheet
            const processesData = [['Process Name', 'Total Count', 'Victim Count', 'Blocker Count', 'Percentage']];
            Object.entries(processedData.processes).forEach(([name, data]) => {
                processesData.push([
                    name,
                    data.total,
                    data.victim,
                    data.blocker,
                    ((data.total / processedData.totalDeadlocks) * 100).toFixed(1) + '%'
                ]);
            });
            const processesWs = XLSX.utils.aoa_to_sheet(processesData);
            XLSX.utils.book_append_sheet(wb, processesWs, 'Common Processes');

            // Unique deadlocks sheet
            const uniqueData = [['Pattern', 'Count']];
            processedData.uniqueDeadlocks.forEach(pattern => {
                uniqueData.push([pattern.signature, pattern.count]);
            });
            const uniqueWs = XLSX.utils.aoa_to_sheet(uniqueData);
            XLSX.utils.book_append_sheet(wb, uniqueWs, 'Unique Deadlocks');

            // Save file
            XLSX.writeFile(wb, `deadlock-analysis-${new Date().toISOString().split('T')[0]}.xlsx`);
        }

        // Export to JSON
        function exportToJson() {
            const exportData = {
                summary: {
                    totalDeadlocks: processedData.totalDeadlocks,
                    uniquePatterns: processedData.uniquePatterns,
                    analysisDate: new Date().toISOString()
                },
                processes: processedData.processes,
                victims: processedData.victims,
                objects: processedData.objects,
                uniqueDeadlocks: processedData.uniqueDeadlocks,
                rawData: deadlockData
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `deadlock-analysis-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Show/hide loading indicator
        function showLoading(isLoading) {
            document.getElementById('loadingSection').classList.toggle('active', isLoading);
            document.getElementById('uploadSection').style.display = isLoading ? 'none' : 'block';
            if (isLoading) {
                document.getElementById('dashboard').classList.remove('active');
            }
        }

        // Show dashboard
        function showDashboard() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('dashboard').classList.add('active');
        }

        // Close modal
        function closeModal() {
            document.getElementById('detailModal').classList.remove('active');
        }

        // Save data to localStorage
        function saveToCache() {
            try {
                const cache = {
                    deadlockData: deadlockData,
                    parsingErrors: parsingErrors,
                    timestamp: new Date().getTime()
                };
                localStorage.setItem('deadlockAnalyzerCache', JSON.stringify(cache));
            } catch (error) {
                console.warn('Could not save to cache:', error);
            }
        }

        // Load data from localStorage
        function loadCachedData() {
            const cachedData = localStorage.getItem('deadlockAnalyzerCache');
            if (cachedData) {
                const cache = JSON.parse(cachedData);
                // Cache expires after 1 hour
                if (new Date().getTime() - cache.timestamp < 3600 * 1000) {
                    deadlockData = cache.deadlockData || [];
                    parsingErrors = cache.parsingErrors || [];
                    if (deadlockData && deadlockData.length > 0) {
                        analyzeDeadlocks();
                        renderDashboard();
                        showDashboard();
                        
                        // Show cache info if there were parsing errors
                        if (parsingErrors && parsingErrors.length > 0) {
                            const cacheMsg = document.createElement('div');
                            cacheMsg.style.cssText = `
                                position: fixed;
                                top: 20px;
                                right: 20px;
                                background: var(--warning);
                                color: var(--bg-primary);
                                padding: 15px 20px;
                                border-radius: 5px;
                                z-index: 1001;
                                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                            `;
                            cacheMsg.innerHTML = `‚ö†Ô∏è Loaded from cache: ${deadlockData.length} successful, ${parsingErrors.length} failed reports`;
                            document.body.appendChild(cacheMsg);
                            
                            setTimeout(() => {
                                if (cacheMsg.parentNode) {
                                    cacheMsg.parentNode.removeChild(cacheMsg);
                                }
                            }, 5000);
                        }
                    }
                }
            }
        }

        // Clear cache
        function clearCache() {
            localStorage.removeItem('deadlockAnalyzerCache');
            deadlockData = [];
            filteredData = [];
            parsingErrors = [];
            rawXmlContent = '';
            document.getElementById('dashboard').classList.remove('active');
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('xmlInput').value = '';
            document.getElementById('connectionStringInput').value = '';
            alert('Cache cleared successfully!');
        }

        // Toggle XML view in modal
        let currentDeadlockXml = '';
        function toggleXmlView() {
            const container = document.getElementById('xmlViewContainer');
            const content = document.getElementById('xmlContent');
            if (container.style.display === 'none') {
                content.textContent = formatXml(currentDeadlockXml);
                container.style.display = 'block';
            } else {
                container.style.display = 'none';
            }
        }

        // Copy XML to clipboard
        function copyXmlToClipboard() {
            navigator.clipboard.writeText(formatXml(currentDeadlockXml)).then(() => {
                alert('XML copied to clipboard!');
            }, () => {
                alert('Failed to copy XML.');
            });
        }

        // Format XML for display
        function formatXml(xml) {
            let formatted = '';
            let indent = '';
            xml.split(/>\s*</).forEach(node => {
                if (node.match(/^\//)) indent = indent.substring(2);
                formatted += indent + '<' + node + '>\r\n';
                if (node.match(/^[^/]/) && !node.match(/\/$/)) indent += '  ';
            });
            return formatted.substring(1, formatted.length - 3);
        }

        // Format SQL with line numbers and highlight deadlock location
        function formatSqlWithLineNumbers(sql, stmtStart = 0, stmtEnd = -1) {
            if (!sql) return 'No SQL text available';
            
            const lines = sql.split(/\r?\n/);
            let currentCharPos = 0;
            let highlightStartLine = -1;
            let highlightEndLine = -1;
            let highlightStartChar = -1;
            let highlightEndChar = -1;
            
            // Calculate which lines contain the deadlock statement
            // Note: stmtStart and stmtEnd are byte positions from SQL Server, need to convert to character positions
            if (stmtStart > 0 && stmtEnd > stmtStart) {
                // Convert byte positions to character positions (SQL Server uses 2 bytes per Unicode character)
                const charStmtStart = Math.floor(stmtStart / 2);
                const charStmtEnd = Math.floor(stmtEnd / 2);
                
                for (let i = 0; i < lines.length; i++) {
                    const lineLength = lines[i].length + 1; // +1 for newline character
                    const lineStart = currentCharPos;
                    const lineEnd = currentCharPos + lineLength - 1;
                    
                    // Check if statement start falls within this line
                    if (highlightStartLine === -1 && charStmtStart >= lineStart && charStmtStart <= lineEnd) {
                        highlightStartLine = i;
                        highlightStartChar = charStmtStart - lineStart;
                    }
                    
                    // Check if statement end falls within this line
                    if (charStmtEnd >= lineStart && charStmtEnd <= lineEnd) {
                        highlightEndLine = i;
                        highlightEndChar = charStmtEnd - lineStart;
                        break;
                    }
                    
                    currentCharPos += lineLength;
                }
            }
            
            const maxLineNumWidth = lines.length.toString().length;
            
            return lines.map((line, index) => {
                const lineNum = (index + 1).toString().padStart(maxLineNumWidth, ' ');
                const isHighlightLine = highlightStartLine !== -1 && index >= highlightStartLine && index <= highlightEndLine;
                
                let formattedLine = line;
                
                // Apply highlighting if this line contains part of the deadlock statement
                if (isHighlightLine) {
                    const startChar = index === highlightStartLine ? highlightStartChar : 0;
                    const endChar = index === highlightEndLine ? highlightEndChar : line.length;
                    
                    if (startChar >= 0 && endChar >= startChar) {
                        const before = line.substring(0, startChar);
                        const highlighted = line.substring(startChar, endChar);
                        const after = line.substring(endChar);
                        
                        formattedLine = before + 
                            '<span style="background-color: #ff6b6b; color: white; padding: 2px 4px; border-radius: 2px; font-weight: bold;">' + 
                            highlighted.replace(/</g, '&lt;').replace(/>/g, '&gt;') + 
                            '</span>' + 
                            after;
                    } else {
                        // Highlight entire line if we can't determine exact character positions
                        formattedLine = '<span style="background-color: rgba(255, 107, 107, 0.2); display: block; margin: -2px -4px; padding: 2px 4px;">' + 
                            line.replace(/</g, '&lt;').replace(/>/g, '&gt;') + 
                            '</span>';
                    }
                } else {
                    // Escape HTML characters for non-highlighted lines
                    formattedLine = line.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                }
                
                const lineNumStyle = isHighlightLine ? 
                    'color: #ff6b6b; font-weight: bold; background-color: rgba(255, 107, 107, 0.1);' : 
                    'color: var(--text-muted);';
                
                return `<span style="${lineNumStyle} user-select: none; margin-right: 10px; padding-right: 5px; border-right: 1px solid var(--border);">${lineNum}</span>${formattedLine}`;
            }).join('\n');
        }

        // Clear all filters
        function clearAllFilters() {
            document.getElementById('processFilter').value = '';
            document.getElementById('queryFilter').value = '';
            document.getElementById('hostnameFilter').value = '';
            document.getElementById('objectFilter').value = '';
            document.getElementById('roleFilter').value = '';
            applyFilters();
        }

        // Change process view
        function changeProcessView() {
            renderProcessesTable();
        }

        // Set filter value from table
        function setFilterValue(filterType, value) {
            let filterInputId;
            switch(filterType) {
                case 'query':
                    filterInputId = 'queryFilter';
                    break;
                case 'hostname':
                    filterInputId = 'hostnameFilter';
                    break;
                default:
                    filterInputId = 'processFilter';
            }
            document.getElementById(filterInputId).value = value;
            applyFilters();
        }

        // Get cache statistics
        function getCacheStats() {
            return {
                sqlHandles: sqlHandleCache.size,
                databaseNames: databaseNameCache.size,
                resourceInfo: resourceInfoCache.size,
                totalCached: sqlHandleCache.size + databaseNameCache.size + resourceInfoCache.size
            };
        }

        // Clear all caches
        function clearAllCaches() {
            sqlHandleCache.clear();
            databaseNameCache.clear();
            resourceInfoCache.clear();
            console.log('All caches cleared');
        }

        // Update cache status display
        function updateCacheStatus() {
            const stats = getCacheStats();
            
            if (document.getElementById('sqlHandleCacheCount')) {
                document.getElementById('sqlHandleCacheCount').textContent = stats.sqlHandles;
            }
            if (document.getElementById('databaseCacheCount')) {
                document.getElementById('databaseCacheCount').textContent = stats.databaseNames;
            }
            if (document.getElementById('resourceCacheCount')) {
                document.getElementById('resourceCacheCount').textContent = stats.resourceInfo;
            }
            if (document.getElementById('totalCacheCount')) {
                document.getElementById('totalCacheCount').textContent = stats.totalCached;
            }
        }

        // Execute diagnostic query
        async function executeDiagnosticQuery(query, queryIndex) {
            const connectionString = document.getElementById('connectionStringInput').value.trim();
            
            if (!connectionString) {
                alert('Connection string is required. Please fill in the connection string at the top of the page.');
                return;
            }

            const resultDiv = document.getElementById(`result-${queryIndex}`);
            resultDiv.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; margin: 10px auto;"></div><p>Executing query...</p>';
            resultDiv.style.display = 'block';

            try {
                const response = await fetch('/api/deadlock/execute-diagnostic-query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        connectionString: connectionString,
                        query: query.replace(/\\n/g, '\n').replace(/\\'/g, "'"),
                        timeoutSeconds: 30
                    }),
                });

                const result = await response.json();

                if (!response.ok || !result.success) {
                    throw new Error(result.message || 'Failed to execute query');
                }

                // Display results
                let resultHtml = `<h5>Query Results (${result.recordCount} rows, ${result.executionTimeMs.toFixed(2)}ms)</h5>`;
                
                if (result.results && result.results.length > 0) {
                    resultHtml += '<table>';
                    
                    // Header
                    resultHtml += '<thead><tr>';
                    result.columnNames.forEach(col => {
                        resultHtml += `<th>${col}</th>`;
                    });
                    resultHtml += '</tr></thead>';
                    
                    // Data rows
                    resultHtml += '<tbody>';
                    result.results.forEach(row => {
                        resultHtml += '<tr>';
                        result.columnNames.forEach(col => {
                            const value = row[col];
                            resultHtml += `<td>${value !== null && value !== undefined ? value : 'NULL'}</td>`;
                        });
                        resultHtml += '</tr>';
                    });
                    resultHtml += '</tbody></table>';
                } else {
                    resultHtml += '<p>No results returned.</p>';
                }

                resultDiv.innerHTML = resultHtml;

            } catch (error) {
                console.error('Error executing diagnostic query:', error);
                resultDiv.innerHTML = `<div style="color: var(--danger); padding: 10px; background: var(--bg-primary); border-radius: 5px;">
                    <strong>Error:</strong> ${error.message}
                </div>`;
            }
        }

        // Load predefined queries
        async function loadPredefinedQueries() {
            const container = document.getElementById('predefinedQueries');
            container.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; margin: 10px auto;"></div><p>Loading predefined queries...</p>';

            try {
                const response = await fetch('/api/deadlock/predefined-queries');
                const queries = await response.json();

                if (!response.ok) {
                    throw new Error('Failed to load predefined queries');
                }

                let html = '<div class="accordion">';
                queries.forEach((query, index) => {
                    html += `
                        <div class="accordion-item">
                            <div class="accordion-header" onclick="toggleAccordion('predefined-${index}')">
                                <span><strong>${query.name}</strong> - ${query.description}</span>
                                <span>‚ñº</span>
                            </div>
                            <div class="accordion-content" id="accordion-predefined-${index}">
                                <div class="code-block" style="margin-bottom: 10px;">${query.query}</div>
                                <button class="btn" onclick="executePredefinedQuery('${query.query.replace(/'/g, "\\'").replace(/\n/g, '\\n')}', 'predefined-${index}')">‚ñ∂Ô∏è Execute Query</button>
                                <div id="result-predefined-${index}" class="diagnostic-result" style="display: none; margin-top: 10px;"></div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';

                container.innerHTML = html;

            } catch (error) {
                console.error('Error loading predefined queries:', error);
                container.innerHTML = `<div style="color: var(--danger); padding: 10px;">
                    <strong>Error:</strong> ${error.message}
                </div>`;
            }
        }

        // Execute predefined query
        async function executePredefinedQuery(query, queryId) {
            return await executeDiagnosticQuery(query, queryId);
        }

    </script>
</body>
</html>
