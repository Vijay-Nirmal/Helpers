<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Server Deadlock Analyzer</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #888888;
            --accent-primary: #007acc;
            --accent-secondary: #005499;
            --border: #404040;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --info: #17a2b8;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-muted: #6c757d;
            --accent-primary: #007bff;
            --accent-secondary: #0056b3;
            --border: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: var(--accent-primary);
            color: white;
        }

        .upload-section {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .textarea-input {
            width: 100%;
            height: 200px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 20px;
        }

        .btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-danger {
            background: var(--danger);
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .dashboard {
            display: none;
        }

        .dashboard.active {
            display: block;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 10px;
            border: 1px solid var(--border);
            text-align: center;
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--accent-primary);
            margin-bottom: 10px;
        }

        .metric-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .section {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-tertiary);
            border-radius: 5px;
            overflow: hidden;
        }

        .table th, .table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .table th {
            background: var(--accent-primary);
            color: white;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
        }

        .table th:hover {
            background: var(--accent-secondary);
        }

        .table tr:hover {
            background: var(--bg-primary);
        }

        .accordion {
            border: 1px solid var(--border);
            border-radius: 5px;
            overflow: hidden;
        }

        .accordion-item {
            border-bottom: 1px solid var(--border);
        }

        .accordion-item:last-child {
            border-bottom: none;
        }

        .accordion-header {
            background: var(--bg-tertiary);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .accordion-header:hover {
            background: var(--border);
        }

        .accordion-content {
            padding: 20px;
            display: none;
            background: var(--bg-primary);
        }

        .accordion-content.active {
            display: block;
        }

        .badge {
            background: var(--accent-primary);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .filter-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-bar input, .filter-bar select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
        }

        .modal.active {
            display: block;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            margin: 2% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 1200px;
            border: 1px solid var(--border);
            position: relative;
        }

        .modal-close {
            position: absolute;
            right: 20px;
            top: 20px;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .process-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .process-card {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .victim-card {
            border-left: 4px solid var(--danger);
        }

        .blocker-card {
            border-left: 4px solid var(--warning);
        }

        .code-block {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .suggestions {
            background: var(--bg-tertiary);
            border-left: 4px solid var(--info);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid var(--border);
            border-top: 4px solid var(--accent-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }

        .deadlock-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            min-height: 200px;
        }

        .diagram-process {
            background: var(--bg-tertiary);
            border: 2px solid var(--accent-primary);
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            text-align: center;
            min-width: 150px;
        }

        .diagram-arrow {
            font-size: 24px;
            color: var(--accent-primary);
            margin: 0 10px;
        }

        .highlight {
            background: var(--warning);
            color: var(--bg-primary);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .diagnostic-result {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
        }

        .diagnostic-result table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .diagnostic-result th,
        .diagnostic-result td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .diagnostic-result th {
            background: var(--accent-primary);
            color: white;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .process-info {
                grid-template-columns: 1fr;
            }
            
            .filter-bar {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üîç SQL Server Deadlock Analyzer</h1>
            <div>
                <button class="theme-toggle" onclick="toggleTheme()">üåô Toggle Theme</button>
                <button class="btn btn-secondary" onclick="clearCache()" style="margin-left: 10px;">üóëÔ∏è Clear Cache</button>
            </div>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 20px; margin-bottom: 20px;">
                <hr style="border: 1px solid var(--border);">
                <h2 style="margin: 0;">Connect to Database</h2>
                <hr style="border: 1px solid var(--border);">
            </div>

            <div id="dbConnectionForm" style="display: grid; grid-template-columns: 1fr; gap: 15px; margin-bottom: 20px;">
                <input type="text" id="connectionStringInput" placeholder="Connection String (e.g., Server=localhost;Database=master;Integrated Security=true;)" style="background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px; border-radius: 5px;">
            </div>
             <div style="text-align: center; margin-bottom: 20px;">
                <button class="btn" onclick="processDeadlocksFromDb()">üîó Connect & Analyze</button>
            </div>

            <div style="text-align: center; margin: 20px 0; color: var(--text-muted);">
                <strong>‚Äî OR ‚Äî</strong>
            </div>

            <div class="upload-area" onclick="document.getElementById('fileInput').click();">
                <input type="file" id="fileInput" accept=".xml,.xdl,.txt" onchange="handleFileUpload(event)">
                <div style="font-size: 3rem; margin-bottom: 15px;">üì§</div>
                <h3>Click to upload or drag & drop</h3>
                <p style="color: var(--text-muted); margin-top: 10px;">Supports XML, XDL, and TXT files</p>
            </div>

            <div style="text-align: center; margin: 20px 0; color: var(--text-muted);">
                <strong>‚Äî OR ‚Äî</strong>
            </div>

            <textarea class="textarea-input" id="xmlInput" placeholder="Paste your deadlock XML here..."></textarea>
            
            <div style="text-align: center;">
                <button class="btn" onclick="processDeadlocksFromFile()">üîÑ Process Deadlocks from File</button>
            </div>
        </div>

        <!-- Loading Section -->
        <div class="loading" id="loadingSection">
            <div class="spinner"></div>
            <h3>Analyzing deadlock reports...</h3>
            <p>Please wait while we process your data.</p>
        </div>

        <!-- Dashboard -->
        <div class="dashboard" id="dashboard">
            <!-- Metrics Cards -->
            <div class="metrics-grid" id="metricsGrid">
                <!-- Metrics will be populated here -->
            </div>

            <!-- Charts Section -->
            <div class="section">
                <h2 class="section-title">üìä Visual Analysis</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="chart-container">
                        <canvas id="victimChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="objectChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Export Section -->
            <div class="section">
                <h2 class="section-title">üì§ Export Data</h2>
                <button class="btn" onclick="exportToExcel()">üìä Export to Excel</button>
                <button class="btn btn-secondary" onclick="exportToJson()" style="margin-left: 10px;">üíæ Export to JSON</button>
            </div>

            <!-- Diagnostic Queries Section -->
            <div class="section">
                <h2 class="section-title">üîß Diagnostic Queries</h2>
                <p style="color: var(--text-secondary); margin-bottom: 20px;">Execute predefined queries to diagnose deadlock-related issues. Make sure to fill in the database connection details above.</p>
                <div id="predefinedQueries">
                    <button class="btn" onclick="loadPredefinedQueries()">üìã Load Predefined Queries</button>
                </div>
            </div>

            <!-- Filter Bar -->
            <div class="section">
                <h2 class="section-title">üîç Filter & Search</h2>
                <div class="filter-bar">
                    <input type="text" id="processFilter" placeholder="Filter by process name..." onkeyup="applyFilters()">
                    <input type="text" id="queryFilter" placeholder="Filter by query/procedure..." onkeyup="applyFilters()">
                    <input type="text" id="hostnameFilter" placeholder="Filter by hostname..." onkeyup="applyFilters()">
                    <input type="text" id="objectFilter" placeholder="Filter by object name..." onkeyup="applyFilters()">
                    <select id="roleFilter" onchange="applyFilters()">
                        <option value="">All Roles</option>
                        <option value="victim">Victims Only</option>
                        <option value="blocker">Blockers Only</option>
                    </select>
                    <button class="btn btn-secondary" onclick="clearAllFilters()" style="margin-left: 10px;">üóëÔ∏è Clear Filters</button>
                </div>
            </div>

            <!-- Common Processes Table -->
            <div class="section">
                <h2 class="section-title">‚öôÔ∏è Common Processes</h2>
                <div class="filter-bar" style="margin-bottom: 20px;">
                    <label for="viewByFilter" style="color: var(--text-secondary); margin-right: 10px;">View by:</label>
                    <select id="viewByFilter" onchange="changeProcessView()" style="margin-right: 20px;">
                        <option value="process">Process Name</option>
                        <option value="query">Query/Procedure</option>
                        <option value="hostname">Hostname</option>
                    </select>
                    <button class="btn btn-secondary" onclick="filterBySelection()" id="filterBySelectionBtn" style="display: none;">üîç Filter by Selected</button>
                </div>
                <div style="overflow-x: auto;">
                    <table class="table" id="processesTable">
                        <thead>
                            <tr>
                                <th onclick="sortTable('processesTable', 0)" id="processTableHeader">Process Name</th>
                                <th onclick="sortTable('processesTable', 1)">Total Count</th>
                                <th onclick="sortTable('processesTable', 2)">Victim Count</th>
                                <th onclick="sortTable('processesTable', 3)">Blocker Count</th>
                                <th onclick="sortTable('processesTable', 4)">Percentage</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="processesTableBody">
                            <!-- Data will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Unique Deadlocks -->
            <div class="section">
                <h2 class="section-title">üîí Unique Deadlock Patterns</h2>
                <div class="accordion" id="uniqueDeadlocks">
                    <!-- Unique deadlocks will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Detailed Deadlock Modal -->
    <div class="modal" id="detailModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <div id="modalContent">
                <!-- Modal content will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let deadlockData = [];
        let filteredData = [];
        let processedData = {
            totalDeadlocks: 0,
            uniquePatterns: 0,
            processes: {},
            victims: {},
            objects: {},
            uniqueDeadlocks: []
        };
        
        // Chart instances for proper cleanup
        let victimChart = null;
        let objectChart = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            loadCachedData();
        });

        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        // Load theme from localStorage
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.body.setAttribute('data-theme', savedTheme);
        }
        loadTheme();

        // Setup drag and drop functionality
        function setupDragAndDrop() {
            const uploadArea = document.querySelector('.upload-area');
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }

        // File upload handler
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        // Process uploaded file
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('xmlInput').value = e.target.result;
                processDeadlocksFromFile();
            };
            reader.readAsText(file);
        }

        // Main processing function for files
        function processDeadlocksFromFile() {
            const xmlContent = document.getElementById('xmlInput').value.trim();
            if (!xmlContent) {
                alert('Please upload a file or paste XML content.');
                return;
            }
            processDeadlocks(xmlContent);
        }

        async function processDeadlocksFromDb() {
            const connectionString = document.getElementById('connectionStringInput').value.trim();

            if (!connectionString) {
                alert('Please enter a connection string.');
                return;
            }

            showLoading(true);

            try {
                const response = await fetch('/api/deadlock/extended-events', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        connectionString
                    }),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to fetch deadlock reports from the database. Status: ${response.status}. ${errorText}`);
                }

                const xmlContent = await response.text();
                if (!xmlContent || xmlContent.trim() === '') {
                     throw new Error('No deadlock reports found in the database for the "system_health" session.');
                }
                processDeadlocks(xmlContent);

            } catch (error) {
                console.error('Error fetching from DB:', error);
                alert(`Error: ${error.message}`);
                showLoading(false);
            }
        }


        // Main processing function
        function processDeadlocks(xmlContent) {
            if (!xmlContent) {
                alert('No XML content to process.');
                showLoading(false);
                return;
            }

            showLoading(true);
            
            setTimeout(() => {
                try {
                    console.log('Starting to parse deadlock XML...');
                    parseDeadlockXML(xmlContent);
                    console.log(`Successfully parsed ${deadlockData.length} deadlock reports`);
                    
                    if (deadlockData.length === 0) {
                        throw new Error('No valid deadlock reports found in the input');
                    }
                    
                    console.log('Analyzing deadlocks...');
                    analyzeDeadlocks();
                    console.log('Rendering dashboard...');
                    renderDashboard();
                    saveToCache();
                    showDashboard();
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: var(--success);
                        color: white;
                        padding: 15px 20px;
                        border-radius: 5px;
                        z-index: 1001;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    `;
                    successMsg.innerHTML = `‚úÖ Successfully processed ${deadlockData.length} deadlock reports!`;
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        if (successMsg.parentNode) {
                            successMsg.parentNode.removeChild(successMsg);
                        }
                    }, 5000);
                    
                } catch (error) {
                    console.error('Error processing deadlocks:', error);
                    
                    // Show detailed error message
                    const errorMsg = `
                        <div style="background: var(--danger); color: white; padding: 20px; border-radius: 5px; margin: 20px 0;">
                            <h3>‚ùå Error Processing Deadlock Data</h3>
                            <p><strong>Error:</strong> ${error.message}</p>
                            <hr style="margin: 15px 0; border: none; border-top: 1px solid rgba(255,255,255,0.3);">
                            <h4>üí° Troubleshooting Tips:</h4>
                            <ul style="margin: 10px 0; padding-left: 20px;">
                                <li><strong>Line-by-line format:</strong> Each line should contain a complete deadlock XML element</li>
                                <li><strong>XML format:</strong> Ensure each line starts with &lt;deadlock&gt; and ends with &lt;/deadlock&gt;</li>
                                <li><strong>Valid XML:</strong> Check for unclosed tags or special characters that need escaping</li>
                                <li><strong>File encoding:</strong> Ensure the file is saved in UTF-8 encoding</li>
                            </ul>
                            <p><strong>Sample format:</strong> Each line should look like:<br>
                            <code style="background: rgba(0,0,0,0.3); padding: 5px; border-radius: 3px; font-size: 12px; word-break: break-all;">
                            &lt;deadlock&gt;&lt;victim-list&gt;...&lt;/victim-list&gt;&lt;process-list&gt;...&lt;/process-list&gt;&lt;resource-list&gt;...&lt;/resource-list&gt;&lt;/deadlock&gt;
                            </code></p>
                        </div>
                    `;
                    
                    // Show error in a modal or alert
                    const errorModal = document.createElement('div');
                    errorModal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.8);
                        z-index: 1002;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 20px;
                    `;
                    
                    const errorContent = document.createElement('div');
                    errorContent.style.cssText = `
                        background: var(--bg-secondary);
                        border-radius: 10px;
                        padding: 30px;
                        max-width: 800px;
                        max-height: 80vh;
                        overflow-y: auto;
                        border: 1px solid var(--border);
                        position: relative;
                    `;
                    
                    errorContent.innerHTML = errorMsg + `
                        <div style="text-align: center; margin-top: 20px;">
                            <button class="btn" onclick="this.closest('.error-modal').remove()">Close</button>
                        </div>
                    `;
                    
                    errorModal.className = 'error-modal';
                    errorModal.appendChild(errorContent);
                    document.body.appendChild(errorModal);
                    
                    // Close modal when clicking outside
                    errorModal.addEventListener('click', function(e) {
                        if (e.target === errorModal) {
                            errorModal.remove();
                        }
                    });
                    
                } finally {
                    showLoading(false);
                }
            }, 100);
        }

        // Parse XML content
        function parseDeadlockXML(xmlContent) {
            deadlockData = [];
            
            // Check if content contains multiple lines (each line is a deadlock report)
            const lines = xmlContent.trim().split('\n').filter(line => line.trim().length > 0);
            
            if (lines.length > 1) {
                // Handle line-by-line format
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.length === 0) continue;
                    
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(line, 'text/xml');
                        
                        // Check for parsing errors
                        const parseError = xmlDoc.getElementsByTagName('parsererror');
                        if (parseError.length > 0) {
                            console.warn(`Error parsing line ${i + 1}:`, parseError[0].textContent);
                            continue;
                        }
                        
                        const deadlocks = xmlDoc.getElementsByTagName('deadlock');
                        if (deadlocks.length > 0) {
                            const parsedDeadlock = parseDeadlockElement(deadlocks[0]);
                            if (parsedDeadlock) {
                                deadlockData.push(parsedDeadlock);
                            }
                        }
                        
                        // Also check for deadlock-list format
                        const deadlockLists = xmlDoc.getElementsByTagName('deadlock-list');
                        if (deadlockLists.length > 0) {
                            const deadlocksInList = deadlockLists[0].getElementsByTagName('deadlock');
                            for (let j = 0; j < deadlocksInList.length; j++) {
                                const parsedDeadlock = parseDeadlockElement(deadlocksInList[j]);
                                if (parsedDeadlock) {
                                    deadlockData.push(parsedDeadlock);
                                }
                            }
                        }
                    } catch (error) {
                        console.warn(`Error parsing line ${i + 1}:`, error);
                        continue;
                    }
                }
            } else {
                // Handle single XML document format
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    // Check for parsing errors
                    const parseError = xmlDoc.getElementsByTagName('parsererror');
                    if (parseError.length > 0) {
                        throw new Error('Invalid XML format: ' + parseError[0].textContent);
                    }
                    
                    // Look for deadlock elements
                    const deadlocks = xmlDoc.getElementsByTagName('deadlock');
                    
                    if (deadlocks.length === 0) {
                        throw new Error('No deadlock elements found in XML');
                    }

                    for (let i = 0; i < deadlocks.length; i++) {
                        const deadlock = deadlocks[i];
                        const parsedDeadlock = parseDeadlockElement(deadlock);
                        if (parsedDeadlock) {
                            deadlockData.push(parsedDeadlock);
                        }
                    }
                } catch (error) {
                    throw new Error('Invalid XML format: ' + error.message);
                }
            }
            
            if (deadlockData.length === 0) {
                throw new Error('No valid deadlock reports found in the input');
            }
        }

        // Parse individual deadlock element
        function parseDeadlockElement(deadlockElement) {
            try {
                const processes = {};
                const resources = {};
                let victimId = null;

                // Parse victim list - handle both formats and multiple victims
                const victimIds = new Set();
                const victimList = deadlockElement.getElementsByTagName('victim-list')[0];
                if (victimList) {
                    const victimProcesses = victimList.getElementsByTagName('victimProcess');
                    for (let v = 0; v < victimProcesses.length; v++) {
                        const victimProcessId = victimProcesses[v].getAttribute('id');
                        if (victimProcessId) {
                            victimIds.add(victimProcessId);
                        }
                    }
                    // For backwards compatibility, set victimId to the first victim
                    victimId = victimIds.size > 0 ? Array.from(victimIds)[0] : null;
                } else {
                    // Handle deadlock-list format where victim is an attribute
                    const singleVictimId = deadlockElement.getAttribute('victim');
                    if (singleVictimId) {
                        victimIds.add(singleVictimId);
                        victimId = singleVictimId;
                    }
                }

                // Parse processes
                const processList = deadlockElement.getElementsByTagName('process-list')[0];
                if (processList) {
                    const processElements = processList.getElementsByTagName('process');
                    for (let j = 0; j < processElements.length; j++) {
                        const proc = processElements[j];
                        const processId = proc.getAttribute('id');
                        
                        processes[processId] = {
                            id: processId,
                            spid: proc.getAttribute('spid'),
                            isVictim: victimIds.has(processId),
                            taskpriority: proc.getAttribute('taskpriority'),
                            logused: proc.getAttribute('logused'),
                            waitresource: proc.getAttribute('waitresource'),
                            waittime: proc.getAttribute('waittime'),
                            ownerId: proc.getAttribute('ownerId'),
                            transactionname: proc.getAttribute('transactionname'),
                            lasttranstarted: proc.getAttribute('lasttranstarted'),
                            lockMode: proc.getAttribute('lockMode'),
                            status: proc.getAttribute('status'),
                            isolationlevel: proc.getAttribute('isolationlevel'),
                            clientapp: proc.getAttribute('clientapp'),
                            hostname: proc.getAttribute('hostname'),
                            loginname: proc.getAttribute('loginname'),
                            currentdb: proc.getAttribute('currentdb'),
                            executionStack: parseExecutionStack(proc),
                            inputBuffer: parseInputBuffer(proc)
                        };
                    }
                } else {
                    // Handle direct process elements (some formats don't have process-list wrapper)
                    const processElements = deadlockElement.getElementsByTagName('process');
                    for (let j = 0; j < processElements.length; j++) {
                        const proc = processElements[j];
                        const processId = proc.getAttribute('id');
                        
                        processes[processId] = {
                            id: processId,
                            spid: proc.getAttribute('spid'),
                            isVictim: victimIds.has(processId),
                            taskpriority: proc.getAttribute('taskpriority'),
                            logused: proc.getAttribute('logused'),
                            waitresource: proc.getAttribute('waitresource'),
                            waittime: proc.getAttribute('waittime'),
                            ownerId: proc.getAttribute('ownerId'),
                            transactionname: proc.getAttribute('transactionname'),
                            lasttranstarted: proc.getAttribute('lasttranstarted'),
                            lockMode: proc.getAttribute('lockMode'),
                            status: proc.getAttribute('status'),
                            isolationlevel: proc.getAttribute('isolationlevel'),
                            clientapp: proc.getAttribute('clientapp'),
                            hostname: proc.getAttribute('hostname'),
                            loginname: proc.getAttribute('loginname'),
                            currentdb: proc.getAttribute('currentdb'),
                            executionStack: parseExecutionStack(proc),
                            inputBuffer: parseInputBuffer(proc)
                        };
                    }
                }

                // Parse resources
                const resourceList = deadlockElement.getElementsByTagName('resource-list')[0];
                if (resourceList) {
                    // Handle key locks
                    const keyLocks = resourceList.getElementsByTagName('keylock');
                    for (let k = 0; k < keyLocks.length; k++) {
                        const lock = keyLocks[k];
                        const lockId = lock.getAttribute('id');
                        
                        resources[lockId] = {
                            id: lockId,
                            type: 'keylock',
                            hobtid: lock.getAttribute('hobtid'),
                            dbid: lock.getAttribute('dbid'),
                            objectname: lock.getAttribute('objectname'),
                            indexname: lock.getAttribute('indexname'),
                            mode: lock.getAttribute('mode'),
                            owners: parseLockOwners(lock),
                            waiters: parseLockWaiters(lock)
                        };
                    }
                    
                    // Handle object locks
                    const objectLocks = resourceList.getElementsByTagName('objectlock');
                    for (let k = 0; k < objectLocks.length; k++) {
                        const lock = objectLocks[k];
                        const lockId = lock.getAttribute('id');
                        
                        resources[lockId] = {
                            id: lockId,
                            type: 'objectlock',
                            objid: lock.getAttribute('objid'),
                            dbid: lock.getAttribute('dbid'),
                            objectname: lock.getAttribute('objectname'),
                            subresource: lock.getAttribute('subresource'),
                            mode: lock.getAttribute('mode'),
                            lockPartition: lock.getAttribute('lockPartition'),
                            owners: parseLockOwners(lock),
                            waiters: parseLockWaiters(lock)
                        };
                    }
                }

                // Determine victims and blockers
                const victims = Object.values(processes).filter(p => p.isVictim);
                const blockers = Object.values(processes).filter(p => !p.isVictim);
                
                // For backwards compatibility, set victim to the first victim if available
                const victim = victims.length > 0 ? victims[0] : null;

                return {
                    id: Date.now() + Math.random(),
                    timestamp: new Date().toISOString(),
                    processes,
                    resources,
                    victimId,
                    victim,
                    victims, // Array of all victims
                    blockers,
                    originalXml: new XMLSerializer().serializeToString(deadlockElement)
                };
            } catch (error) {
                console.warn('Error parsing deadlock element:', error);
                return null;
            }
        }

        // Parse execution stack from process
        function parseExecutionStack(processElement) {
            const stack = [];
            const executionStack = processElement.getElementsByTagName('executionStack')[0];
            if (executionStack) {
                const frames = executionStack.getElementsByTagName('frame');
                for (let i = 0; i < frames.length; i++) {
                    const frame = frames[i];
                    stack.push({
                        procname: frame.getAttribute('procname'),
                        line: frame.getAttribute('line'),
                        stmtstart: frame.getAttribute('stmtstart'),
                        stmtend: frame.getAttribute('stmtend'),
                        sqlhandle: frame.getAttribute('sqlhandle'),
                        statement: frame.textContent.trim()
                    });
                }
            }
            return stack;
        }

        // Parse input buffer from process
        function parseInputBuffer(processElement) {
            const inputBuf = processElement.getElementsByTagName('inputbuf')[0];
            return inputBuf ? inputBuf.textContent.trim() : '';
        }

        // Parse lock owners
        function parseLockOwners(lockElement) {
            const owners = [];
            const ownerList = lockElement.getElementsByTagName('owner-list')[0];
            if (ownerList) {
                const ownerElements = ownerList.getElementsByTagName('owner');
                for (let i = 0; i < ownerElements.length; i++) {
                    const owner = ownerElements[i];
                    owners.push({
                        id: owner.getAttribute('id'),
                        mode: owner.getAttribute('mode')
                    });
                }
            }
            return owners;
        }

        // Parse lock waiters
        function parseLockWaiters(lockElement) {
            const waiters = [];
            const waiterList = lockElement.getElementsByTagName('waiter-list')[0];
            if (waiterList) {
                const waiterElements = waiterList.getElementsByTagName('waiter');
                for (let i = 0; i < waiterElements.length; i++) {
                    const waiter = waiterElements[i];
                    waiters.push({
                        id: waiter.getAttribute('id'),
                        mode: waiter.getAttribute('mode'),
                        requestType: waiter.getAttribute('requestType')
                    });
                }
            }
            return waiters;
        }

        // Analyze deadlock data
        function analyzeDeadlocks() {
            processedData = {
                totalDeadlocks: deadlockData.length,
                uniquePatterns: 0,
                processes: {},
                queries: {},
                hostnames: {},
                victims: {},
                objects: {},
                uniqueDeadlocks: []
            };

            const uniqueSignatures = new Set();

            deadlockData.forEach(deadlock => {
                // Process victims and processes - handle multiple victims
                const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
                
                allVictims.forEach(victim => {
                    if (victim) {
                        const victimName = getProcessName(victim);
                        const queryName = getQueryName(victim);
                        const hostname = getHostname(victim);
                        
                        processedData.victims[victimName] = (processedData.victims[victimName] || 0) + 1;
                        
                        // Process name data
                        if (!processedData.processes[victimName]) {
                            processedData.processes[victimName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.processes[victimName].total++;
                        processedData.processes[victimName].victim++;
                        
                        // Query data
                        if (!processedData.queries[queryName]) {
                            processedData.queries[queryName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.queries[queryName].total++;
                        processedData.queries[queryName].victim++;
                        
                        // Hostname data
                        if (!processedData.hostnames[hostname]) {
                            processedData.hostnames[hostname] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.hostnames[hostname].total++;
                        processedData.hostnames[hostname].victim++;
                    }
                });

                // Process blockers
                if (deadlock.blockers && deadlock.blockers.length > 0) {
                    deadlock.blockers.forEach(blocker => {
                        const blockerName = getProcessName(blocker);
                        const queryName = getQueryName(blocker);
                        const hostname = getHostname(blocker);
                        
                        // Process name data
                        if (!processedData.processes[blockerName]) {
                            processedData.processes[blockerName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.processes[blockerName].total++;
                        processedData.processes[blockerName].blocker++;
                        
                        // Query data
                        if (!processedData.queries[queryName]) {
                            processedData.queries[queryName] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.queries[queryName].total++;
                        processedData.queries[queryName].blocker++;
                        
                        // Hostname data
                        if (!processedData.hostnames[hostname]) {
                            processedData.hostnames[hostname] = { total: 0, victim: 0, blocker: 0 };
                        }
                        processedData.hostnames[hostname].total++;
                        processedData.hostnames[hostname].blocker++;
                    });
                }

                // Process objects
                if (deadlock.resources) {
                    Object.values(deadlock.resources).forEach(resource => {
                        if (resource.objectname) {
                            processedData.objects[resource.objectname] = (processedData.objects[resource.objectname] || 0) + 1;
                        }
                    });
                }

                // Create unique signature
                const signature = createDeadlockSignature(deadlock);
                if (!uniqueSignatures.has(signature.key)) {
                    uniqueSignatures.add(signature.key);
                    processedData.uniqueDeadlocks.push({
                        signature: signature.display,
                        key: signature.key,
                        count: 1,
                        deadlocks: [deadlock]
                    });
                } else {
                    const existing = processedData.uniqueDeadlocks.find(u => u.key === signature.key);
                    if (existing) {
                        existing.count++;
                        existing.deadlocks.push(deadlock);
                    }
                }
            });

            processedData.uniquePatterns = processedData.uniqueDeadlocks.length;
            filteredData = [...deadlockData];
        }

        // Get process name for display
        function getProcessName(process) {
            if (!process) return 'Unknown';
            
            if (process.executionStack && process.executionStack.length > 0) {
                const frame = process.executionStack[0];
                if (frame.procname && frame.procname !== 'adhoc') {
                    return frame.procname;
                }
            }
            
            if (process.clientapp) {
                return process.clientapp;
            }
            
            return `SPID ${process.spid || 'Unknown'}`;
        }

        // Get query/procedure name for display
        function getQueryName(process) {
            if (!process) return 'Unknown';
            
            if (process.executionStack && process.executionStack.length > 0) {
                const frame = process.executionStack[0];
                if (frame.procname && frame.procname !== 'adhoc') {
                    return frame.procname;
                }
                // For ad-hoc queries, try to extract meaningful part of the statement
                if (frame.statement) {
                    let stmt = frame.statement.trim();
                    // Remove extra whitespace and newlines
                    stmt = stmt.replace(/\s+/g, ' ');
                    // Truncate long statements
                    if (stmt.length > 100) {
                        stmt = stmt.substring(0, 100) + '...';
                    }
                    return stmt || 'Ad-hoc Query';
                }
            }
            
            if (process.inputBuffer) {
                let buffer = process.inputBuffer.trim();
                buffer = buffer.replace(/\s+/g, ' ');
                if (buffer.length > 100) {
                    buffer = buffer.substring(0, 100) + '...';
                }
                return buffer || 'Unknown Query';
            }
            
            return 'Unknown Query';
        }

        // Get hostname for display
        function getHostname(process) {
            if (!process) return 'Unknown';
            return process.hostname || 'Unknown';
        }

        // Create unique deadlock signature
        function createDeadlockSignature(deadlock) {
            // Handle multiple victims
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const victimNames = allVictims.map(v => getProcessName(v)).join(', ');
            const victimLines = allVictims.map(v => 
                v && v.executionStack && v.executionStack.length > 0 ? v.executionStack[0].line : '0'
            ).join(', ');
            
            const blockerNames = deadlock.blockers ? deadlock.blockers.map(b => getProcessName(b)).join(', ') : 'None';
            const blockerLines = deadlock.blockers ? deadlock.blockers.map(b => 
                b.executionStack && b.executionStack.length > 0 ? b.executionStack[0].line : '0'
            ).join(', ') : '0';

            const key = `${victimNames}:${victimLines}|${blockerNames}:${blockerLines}`;
            const display = `[VICTIMS: ${victimNames} (Lines ${victimLines})] vs [BLOCKERS: ${blockerNames} (Lines ${blockerLines})]`;

            return { key, display };
        }

        // Render dashboard
        function renderDashboard() {
            renderMetrics();
            renderProcessesTable();
            renderUniqueDeadlocks();
            renderCharts();
        }

        // Render metrics cards
        function renderMetrics() {
            const metricsGrid = document.getElementById('metricsGrid');
            const mostFrequentVictim = Object.keys(processedData.victims).reduce((a, b) => 
                processedData.victims[a] > processedData.victims[b] ? a : b, Object.keys(processedData.victims)[0] || 'None');
            
            const processesWithBlockers = Object.keys(processedData.processes)
                .filter(p => processedData.processes[p].blocker > 0);
            const mostFrequentBlocker = processesWithBlockers.length > 0 
                ? processesWithBlockers.reduce((a, b) => processedData.processes[a].blocker > processedData.processes[b].blocker ? a : b)
                : 'None';

            metricsGrid.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${processedData.totalDeadlocks}</div>
                    <div class="metric-label">Total Deadlocks</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${processedData.uniquePatterns}</div>
                    <div class="metric-label">Unique Patterns</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${mostFrequentVictim}</div>
                    <div class="metric-label">Most Frequent Victim</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${mostFrequentBlocker}</div>
                    <div class="metric-label">Most Frequent Blocker</div>
                </div>
            `;
        }

        // Render processes table
        // Render processes table
        function renderProcessesTable() {
            const tbody = document.getElementById('processesTableBody');
            const header = document.getElementById('processTableHeader');
            const viewBy = document.getElementById('viewByFilter').value;
            const totalDeadlocks = processedData.totalDeadlocks;
            
            let dataSource, headerText;
            switch(viewBy) {
                case 'query':
                    dataSource = processedData.queries;
                    headerText = 'Query/Procedure';
                    break;
                case 'hostname':
                    dataSource = processedData.hostnames;
                    headerText = 'Hostname';
                    break;
                default:
                    dataSource = processedData.processes;
                    headerText = 'Process Name';
            }
            
            header.textContent = headerText;
            
            const sortedData = Object.entries(dataSource)
                .sort(([,a], [,b]) => b.total - a.total);

            tbody.innerHTML = sortedData.map(([name, data]) => `
                <tr>
                    <td title="${name}">${name.length > 80 ? name.substring(0, 80) + '...' : name}</td>
                    <td>${data.total}</td>
                    <td>${data.victim}</td>
                    <td>${data.blocker}</td>
                    <td>${((data.total / totalDeadlocks) * 100).toFixed(1)}%</td>
                    <td>
                        <button class="btn btn-secondary" onclick="setFilterValue('${viewBy}', '${name.replace(/'/g, "\\'")}')">üîç Filter</button>
                    </td>
                </tr>
            `).join('');
        }

        // Render unique deadlocks accordion
        function renderUniqueDeadlocks() {
            const container = document.getElementById('uniqueDeadlocks');
            
            const sortedDeadlocks = processedData.uniqueDeadlocks
                .sort((a, b) => b.count - a.count);

            container.innerHTML = sortedDeadlocks.map((pattern, index) => `
                <div class="accordion-item">
                    <div class="accordion-header" onclick="toggleAccordion(${index})">
                        <span>${pattern.signature}</span>
                        <span class="badge">${pattern.count}</span>
                    </div>
                    <div class="accordion-content" id="accordion-${index}">
                        <h4>Individual Deadlock Reports (${pattern.count})</h4>
                        ${pattern.deadlocks.map((deadlock, i) => {
                            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
                            const victimInfo = allVictims.map(v => `${getProcessName(v)} (SPID: ${v ? v.spid : 'N/A'})`).join(', ');
                            const blockerInfo = deadlock.blockers ? deadlock.blockers.map(b => `${getProcessName(b)} (SPID: ${b.spid})`).join(', ') : 'None';
                            
                            return `
                            <div style="background: var(--bg-tertiary); padding: 15px; margin: 10px 0; border-radius: 5px; cursor: pointer;" onclick="showDeadlockDetail('${pattern.key}', ${i})">
                                <strong>Report #${i + 1}</strong> - 
                                Victims: ${victimInfo} |
                                Blockers: ${blockerInfo}
                            </div>
                        `;
                        }).join('')}
                    </div>
                </div>
            `).join('');
        }

        // Toggle accordion
        function toggleAccordion(index) {
            const content = document.getElementById(`accordion-${index}`);
            if (content) {
                content.classList.toggle('active');
            }
        }

        // Show detailed deadlock view
        function showDeadlockDetail(patternKey, deadlockIndex) {
            const pattern = processedData.uniqueDeadlocks.find(p => p.key === patternKey);
            if (!pattern || !pattern.deadlocks[deadlockIndex]) return;

            const deadlock = pattern.deadlocks[deadlockIndex];
            const modalContent = document.getElementById('modalContent');
            
            // Store current deadlock XML for the XML view
            currentDeadlockXml = deadlock.originalXml || '';
            
            // Handle multiple victims
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const hasBlockers = deadlock.blockers && deadlock.blockers.length > 0;

            modalContent.innerHTML = `
                <h2>üîç Detailed Deadlock Analysis</h2>
                
                <!-- Process Information -->
                <div class="process-info">
                    <div class="process-card victim-card">
                        <h3>üéØ Victim Process${allVictims.length > 1 ? 'es' : ''}</h3>
                        ${allVictims.map(victim => renderProcessDetails(victim, true)).join('<hr style="margin: 15px 0;">')}
                    </div>
                    <div class="process-card blocker-card">
                        <h3>üö´ Blocker Process${hasBlockers && deadlock.blockers.length > 1 ? 'es' : ''}</h3>
                        ${hasBlockers ? deadlock.blockers.map(blocker => renderProcessDetails(blocker, false)).join('<hr style="margin: 15px 0;">') : '<p>No clear blocker processes identified</p>'}
                    </div>
                </div>

                <!-- Deadlock Diagram -->
                <div class="section">
                    <h3>üìä Deadlock Visualization</h3>
                    ${renderDeadlockDiagram(deadlock)}
                </div>

                <!-- Resource Information -->
                <div class="section">
                    <h3>üîí Locked Resources</h3>
                    ${renderResourceDetails(deadlock.resources)}
                </div>

                <!-- XML View -->
                <div class="section">
                    <h3>üìÑ Raw XML Data</h3>
                    <div style="margin-bottom: 10px;">
                        <button class="btn btn-secondary" onclick="toggleXmlView()">üìã Toggle XML View</button>
                        <button class="btn btn-secondary" onclick="copyXmlToClipboard()" style="margin-left: 10px;">üìã Copy XML</button>
                    </div>
                    <div id="xmlViewContainer" style="display: none;">
                        <pre class="code-block" id="xmlContent" style="max-height: 400px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; font-size: 11px;"></pre>
                    </div>
                </div>

                <!-- Diagnostic Queries -->
                <div class="section">
                    <h3>üîß Diagnostic Queries</h3>
                    ${renderDiagnosticQueries(deadlock)}
                </div>

                <!-- Fix Suggestions -->
                <div class="section">
                    <h3>üí° Fix Suggestions</h3>
                    ${renderFixSuggestions(deadlock)}
                </div>
            `;

            document.getElementById('detailModal').classList.add('active');
        }

        // Render process details
        function renderProcessDetails(process, isVictim) {
            if (!process) return '<p>No process information available</p>';

            return `
                <p><strong>SPID:</strong> ${process.spid}</p>
                <p><strong>Application:</strong> ${process.clientapp || 'Unknown'}</p>
                <p><strong>Host:</strong> ${process.hostname || 'Unknown'}</p>
                <p><strong>Login:</strong> ${process.loginname || 'Unknown'}</p>
                <p><strong>Isolation Level:</strong> ${process.isolationlevel || 'Unknown'}</p>
                <p><strong>Transaction:</strong> ${process.transactionname || 'Unknown'}</p>
                <p><strong>Wait Resource:</strong> ${process.waitresource || 'None'}</p>
                <p><strong>Lock Mode:</strong> ${process.lockMode || 'Unknown'}</p>
                
                <h4>Execution Stack:</h4>
                ${process.executionStack.map(frame => `
                    <div class="code-block">
                        <strong>Procedure:</strong> ${frame.procname}<br>
                        <strong>Line:</strong> <span class="highlight">${frame.line}</span><br>
                        <strong>Statement:</strong> ${frame.statement}
                    </div>
                `).join('')}
                
                <h4>Input Buffer:</h4>
                <div class="code-block">${process.inputBuffer || 'No input buffer available'}</div>
            `;
        }

        // Render deadlock diagram
        function renderDeadlockDiagram(deadlock) {
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const hasBlockers = deadlock.blockers && deadlock.blockers.length > 0;
            
            const victimDisplay = allVictims.length > 0 
                ? allVictims.map(v => `${getProcessName(v)}<br><small>SPID: ${v ? v.spid : 'N/A'}</small>`).join('<br>')
                : 'Unknown';
                
            const victimSpids = allVictims.length > 0
                ? allVictims.map(v => v ? v.spid : 'N/A').join(', ')
                : 'N/A';
                
            const blockerDisplay = hasBlockers 
                ? deadlock.blockers.map(b => `${getProcessName(b)}<br><small>SPID: ${b.spid}</small>`).join('<br>')
                : 'None';
                
            const blockerSpids = hasBlockers
                ? deadlock.blockers.map(b => b.spid).join(', ')
                : 'N/A';

            return `
                <div class="deadlock-diagram">
                    <div class="diagram-process">
                        <strong>Victim${allVictims.length > 1 ? 's' : ''}</strong><br>
                        ${victimDisplay}
                    </div>
                    <div class="diagram-arrow">‚áÑ</div>
                    <div style="text-align: center;">
                        <strong>Resource Contention</strong><br>
                        <small>Lock Cycle Detected</small>
                    </div>
                    <div class="diagram-arrow">‚áÑ</div>
                    <div class="diagram-process">
                        <strong>Blocker${hasBlockers && deadlock.blockers.length > 1 ? 's' : ''}</strong><br>
                        ${blockerDisplay}
                    </div>
                </div>
            `;
        }

        // Render resource details
        function renderResourceDetails(resources) {
            return Object.values(resources).map(resource => `
                <div style="background: var(--bg-tertiary); padding: 15px; margin: 10px 0; border-radius: 5px;">
                    <p><strong>Object:</strong> ${resource.objectname || 'Unknown'}</p>
                    <p><strong>Index:</strong> ${resource.indexname || 'Unknown'}</p>
                    <p><strong>Lock Type:</strong> ${resource.type}</p>
                    <p><strong>Lock Mode:</strong> ${resource.mode}</p>
                    <p><strong>Database ID:</strong> ${resource.dbid}</p>
                    <p><strong>Hobt ID:</strong> ${resource.hobtid}</p>
                </div>
            `).join('');
        }

        // Render diagnostic queries
        function renderDiagnosticQueries(deadlock) {
            const queries = [];
            let queryIndex = 0;
            
            // SQL Handle queries
            if (deadlock.victim && deadlock.victim.executionStack.length > 0) {
                const sqlHandle = deadlock.victim.executionStack[0].sqlhandle;
                if (sqlHandle) {
                    const query = `SELECT 
    text,
    statement_start_offset,
    statement_end_offset
FROM sys.dm_exec_sql_text(${sqlHandle});`;
                    
                    queries.push(`
                        <h4>Get Full Query Text (Victim):</h4>
                        <div class="code-block" id="query-${queryIndex}">${query}</div>
                        <button class="btn btn-secondary" onclick="executeDiagnosticQuery('${query.replace(/'/g, "\\'").replace(/\n/g, '\\n')}', ${queryIndex})" style="margin-top: 10px;">‚ñ∂Ô∏è Execute Query</button>
                        <div id="result-${queryIndex}" class="diagnostic-result" style="display: none; margin-top: 10px;"></div>
                    `);
                    queryIndex++;
                }
            }

            // Resource queries
            Object.values(deadlock.resources).forEach(resource => {
                if (resource.hobtid) {
                    const query = `SELECT 
    o.name AS table_name,
    i.name AS index_name,
    i.type_desc
FROM sys.partitions p
JOIN sys.objects o ON p.object_id = o.object_id
JOIN sys.indexes i ON p.object_id = i.object_id AND p.index_id = i.index_id
WHERE p.hobt_id = ${resource.hobtid};`;

                    queries.push(`
                        <h4>Find Object/Index for Hobt ID ${resource.hobtid}:</h4>
                        <div class="code-block" id="query-${queryIndex}">${query}</div>
                        <button class="btn btn-secondary" onclick="executeDiagnosticQuery('${query.replace(/'/g, "\\'").replace(/\n/g, '\\n')}', ${queryIndex})" style="margin-top: 10px;">‚ñ∂Ô∏è Execute Query</button>
                        <div id="result-${queryIndex}" class="diagnostic-result" style="display: none; margin-top: 10px;"></div>
                    `);
                    queryIndex++;
                }
            });

            return queries.length > 0 ? queries.join('') : '<p>No diagnostic queries available</p>';
        }

        // Render fix suggestions
        function renderFixSuggestions(deadlock) {
            const suggestions = [];
            const allVictims = deadlock.victims || (deadlock.victim ? [deadlock.victim] : []);
            const hasBlockers = deadlock.blockers && deadlock.blockers.length > 0;

            // Analyze deadlock pattern and provide suggestions
            if (allVictims.length > 0) {
                suggestions.push(`
                    <div class="suggestions">
                        <h4>üîß General Recommendations:</h4>
                        <ul>
                            <li>Keep transactions as short as possible</li>
                            <li>Access objects in the same order in all procedures</li>
                            <li>Use the lowest possible isolation level</li>
                            <li>Consider using WITH (NOLOCK) for read operations where data consistency is not critical</li>
                            ${allVictims.length > 1 ? '<li><strong>Multiple Victims Detected:</strong> This indicates a complex deadlock scenario - consider implementing retry logic</li>' : ''}
                        </ul>
                    </div>
                `);

                // Check for common patterns
                const victimResources = allVictims.map(v => v ? v.waitresource : '').filter(r => r);
                const hasKeyLocks = victimResources.some(r => r.includes('KEY:'));
                const hasObjectLocks = victimResources.some(r => r.includes('OBJECT:'));
                
                if (hasKeyLocks) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>üéØ Key Lock Deadlock:</h4>
                            <ul>
                                <li>Consider using WITH (ROWLOCK) hint to prevent lock escalation</li>
                                <li>Review index fragmentation and consider rebuilding if > 30%</li>
                                <li>Use covering indexes to reduce key lookups</li>
                            </ul>
                        </div>
                    `);
                }
                
                if (hasObjectLocks) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>üè¢ Object Lock Deadlock:</h4>
                            <ul>
                                <li>This type of deadlock often involves table-level locks</li>
                                <li>Consider breaking large transactions into smaller ones</li>
                                <li>Review the use of TABLOCK and HOLDLOCK hints</li>
                                <li>Implement proper transaction ordering across all applications</li>
                            </ul>
                        </div>
                    `);
                }

                // Check for read-then-update pattern if we have victims and blockers
                if (hasBlockers && allVictims.some(v => v && v.lockMode === 'S') && deadlock.blockers.some(b => b.lockMode === 'X')) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>üìñ Read-Then-Update Deadlock:</h4>
                            <ul>
                                <li>Use WITH (UPDLOCK) on the initial SELECT to prevent this pattern</li>
                                <li>Consider using MERGE statement instead of separate SELECT/UPDATE</li>
                                <li>Implement retry logic with exponential backoff</li>
                            </ul>
                        </div>
                    `);
                }
                
                if (allVictims.length > 1) {
                    suggestions.push(`
                        <div class="suggestions">
                            <h4>‚ö†Ô∏è Multi-Victim Deadlock:</h4>
                            <ul>
                                <li>This is a complex deadlock involving ${allVictims.length} victim processes</li>
                                <li>Implement comprehensive retry logic with exponential backoff</li>
                                <li>Consider using snapshot isolation level if applicable</li>
                                <li>Review application architecture for potential redesign</li>
                                <li>Monitor for escalation patterns - this may indicate systemic issues</li>
                            </ul>
                        </div>
                    `);
                }
            }

            return suggestions.length > 0 ? suggestions.join('') : '<p>No specific suggestions available</p>';
        }

        // Render charts
        function renderCharts() {
            // Destroy existing charts if they exist
            if (victimChart) {
                victimChart.destroy();
                victimChart = null;
            }
            if (objectChart) {
                objectChart.destroy();
                objectChart = null;
            }
            
            renderVictimChart();
            renderObjectChart();
        }

        // Render victim distribution chart
        function renderVictimChart() {
            const ctx = document.getElementById('victimChart').getContext('2d');
            const victims = Object.entries(processedData.victims)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);

            victimChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: victims.map(([name]) => name),
                    datasets: [{
                        data: victims.map(([, count]) => count),
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
                            '#9966FF', '#FF9F40', '#FF6384', '#36A2EB',
                            '#FFCE56', '#4BC0C0'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top Victim Processes',
                            color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                        },
                        legend: {
                            labels: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            }
                        }
                    }
                }
            });
        }

        // Render object distribution chart
        function renderObjectChart() {
            const ctx = document.getElementById('objectChart').getContext('2d');
            const objects = Object.entries(processedData.objects)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);

            objectChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: objects.map(([name]) => name.split('.').pop()),
                    datasets: [{
                        label: 'Deadlock Count',
                        data: objects.map(([, count]) => count),
                        backgroundColor: '#36A2EB'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top Affected Objects',
                            color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                        },
                        legend: {
                            labels: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            }
                        }
                    },
                    scales: {
                        y: {
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            },
                            grid: {
                                color: getComputedStyle(document.body).getPropertyValue('--border')
                            }
                        },
                        x: {
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-primary')
                            },
                            grid: {
                                color: getComputedStyle(document.body).getPropertyValue('--border')
                            }
                        }
                    }
                }
            });
        }

        // Apply filters
        // Apply filters
        function applyFilters() {
            const processFilter = document.getElementById('processFilter').value.toLowerCase();
            const queryFilter = document.getElementById('queryFilter').value.toLowerCase();
            const hostnameFilter = document.getElementById('hostnameFilter').value.toLowerCase();
            const objectFilter = document.getElementById('objectFilter').value.toLowerCase();
            const roleFilter = document.getElementById('roleFilter').value;

            // Check if any filters are active
            const hasActiveFilters = processFilter || queryFilter || hostnameFilter || objectFilter || roleFilter;

            filteredData = deadlockData.filter(deadlock => {
                let matches = true;

                // Process name filter
                if (processFilter) {
                    const allProcesses = [...(deadlock.victims || []), ...(deadlock.blockers || [])];
                    const processNames = allProcesses.map(p => getProcessName(p).toLowerCase()).join(' ');
                    matches = matches && processNames.includes(processFilter);
                }

                // Query/procedure filter
                if (queryFilter) {
                    const allProcesses = [...(deadlock.victims || []), ...(deadlock.blockers || [])];
                    const queryNames = allProcesses.map(p => getQueryName(p).toLowerCase()).join(' ');
                    matches = matches && queryNames.includes(queryFilter);
                }

                // Hostname filter
                if (hostnameFilter) {
                    const allProcesses = [...(deadlock.victims || []), ...(deadlock.blockers || [])];
                    const hostnames = allProcesses.map(p => getHostname(p).toLowerCase()).join(' ');
                    matches = matches && hostnames.includes(hostnameFilter);
                }

                // Object filter
                if (objectFilter) {
                    const objectNames = Object.values(deadlock.resources || {})
                        .map(r => (r.objectname || '').toLowerCase())
                        .join(' ');
                    matches = matches && objectNames.includes(objectFilter);
                }

                // Role filter
                if (roleFilter) {
                    if (roleFilter === 'victim' && (!deadlock.victims || deadlock.victims.length === 0)) {
                        matches = false;
                    }
                    if (roleFilter === 'blocker' && (!deadlock.blockers || deadlock.blockers.length === 0)) {
                        matches = false;
                    }
                }

                return matches;
            });

            // Re-analyze and re-render data (either filtered or all data if no filters)
            if (hasActiveFilters && filteredData.length !== deadlockData.length) {
                // Apply filters - temporarily replace deadlockData with filtered data
                const originalData = deadlockData;
                deadlockData = filteredData;
                analyzeDeadlocks();
                renderDashboard();
                deadlockData = originalData;
            } else if (!hasActiveFilters) {
                // No filters active - show all data
                filteredData = [...deadlockData];
                analyzeDeadlocks();
                renderDashboard();
            }
        }

        // Sort table
        function sortTable(tableId, columnIndex) {
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                const aVal = a.cells[columnIndex].textContent.trim();
                const bVal = b.cells[columnIndex].textContent.trim();

                // Check if values are numeric
                const aNum = parseFloat(aVal.replace(/[^\d.-]/g, ''));
                const bNum = parseFloat(bVal.replace(/[^\d.-]/g, ''));

                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return bNum - aNum; // Descending for numbers
                } else {
                    return aVal.localeCompare(bVal); // Ascending for text
                }
            });

            rows.forEach(row => tbody.appendChild(row));
        }

        // Export to Excel
        function exportToExcel() {
            const wb = XLSX.utils.book_new();



            // Summary sheet
            const summaryData = [
                ['Total Deadlocks', processedData.totalDeadlocks],
                ['Unique Patterns', processedData.uniquePatterns],
                ['Analysis Date', new Date().toISOString()]
            ];
            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');

            // Processes sheet
            const processesData = [['Process Name', 'Total Count', 'Victim Count', 'Blocker Count', 'Percentage']];
            Object.entries(processedData.processes).forEach(([name, data]) => {
                processesData.push([
                    name,
                    data.total,
                    data.victim,
                    data.blocker,
                    ((data.total / processedData.totalDeadlocks) * 100).toFixed(1) + '%'
                ]);
            });
            const processesWs = XLSX.utils.aoa_to_sheet(processesData);
            XLSX.utils.book_append_sheet(wb, processesWs, 'Common Processes');

            // Unique deadlocks sheet
            const uniqueData = [['Pattern', 'Count']];
            processedData.uniqueDeadlocks.forEach(pattern => {
                uniqueData.push([pattern.signature, pattern.count]);
            });
            const uniqueWs = XLSX.utils.aoa_to_sheet(uniqueData);
            XLSX.utils.book_append_sheet(wb, uniqueWs, 'Unique Deadlocks');

            // Save file
            XLSX.writeFile(wb, `deadlock-analysis-${new Date().toISOString().split('T')[0]}.xlsx`);
        }

        // Export to JSON
        function exportToJson() {
            const exportData = {
                summary: {
                    totalDeadlocks: processedData.totalDeadlocks,
                    uniquePatterns: processedData.uniquePatterns,
                    analysisDate: new Date().toISOString()
                },
                processes: processedData.processes,
                victims: processedData.victims,
                objects: processedData.objects,
                uniqueDeadlocks: processedData.uniqueDeadlocks,
                rawData: deadlockData
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `deadlock-analysis-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Show/hide loading indicator
        function showLoading(isLoading) {
            document.getElementById('loadingSection').classList.toggle('active', isLoading);
            document.getElementById('uploadSection').style.display = isLoading ? 'none' : 'block';
            if (isLoading) {
                document.getElementById('dashboard').classList.remove('active');
            }
        }

        // Show dashboard
        function showDashboard() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('dashboard').classList.add('active');
        }

        // Close modal
        function closeModal() {
            document.getElementById('detailModal').classList.remove('active');
        }

        // Save data to localStorage
        function saveToCache() {
            try {
                const cache = {
                    deadlockData: deadlockData,
                    timestamp: new Date().getTime()
                };
                localStorage.setItem('deadlockAnalyzerCache', JSON.stringify(cache));
            } catch (error) {
                console.warn('Could not save to cache:', error);
            }
        }

        // Load data from localStorage
        function loadCachedData() {
            const cachedData = localStorage.getItem('deadlockAnalyzerCache');
            if (cachedData) {
                const cache = JSON.parse(cachedData);
                // Cache expires after 1 hour
                if (new Date().getTime() - cache.timestamp < 3600 * 1000) {
                    deadlockData = cache.deadlockData;
                    if (deadlockData && deadlockData.length > 0) {
                        analyzeDeadlocks();
                        renderDashboard();
                        showDashboard();
                    }
                }
            }
        }

        // Clear cache
        function clearCache() {
            localStorage.removeItem('deadlockAnalyzerCache');
            deadlockData = [];
            filteredData = [];
            document.getElementById('dashboard').classList.remove('active');
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('xmlInput').value = '';
            alert('Cache cleared successfully!');
        }

        // Toggle XML view in modal
        let currentDeadlockXml = '';
        function toggleXmlView() {
            const container = document.getElementById('xmlViewContainer');
            const content = document.getElementById('xmlContent');
            if (container.style.display === 'none') {
                content.textContent = formatXml(currentDeadlockXml);
                container.style.display = 'block';
            } else {
                container.style.display = 'none';
            }
        }

        // Copy XML to clipboard
        function copyXmlToClipboard() {
            navigator.clipboard.writeText(formatXml(currentDeadlockXml)).then(() => {
                alert('XML copied to clipboard!');
            }, () => {
                alert('Failed to copy XML.');
            });
        }

        // Format XML for display
        function formatXml(xml) {
            let formatted = '';
            let indent = '';
            xml.split(/>\s*</).forEach(node => {
                if (node.match(/^\//)) indent = indent.substring(2);
                formatted += indent + '<' + node + '\r\n';
                if (node.match(/^[^/]/) && !node.match(/\/$/)) indent += '  ';
            });
            return formatted.substring(1, formatted.length - 2);
        }

        // Clear all filters
        function clearAllFilters() {
            document.getElementById('processFilter').value = '';
            document.getElementById('queryFilter').value = '';
            document.getElementById('hostnameFilter').value = '';
            document.getElementById('objectFilter').value = '';
            document.getElementById('roleFilter').value = '';
            applyFilters();
        }

        // Change process view
        function changeProcessView() {
            renderProcessesTable();
        }

        // Set filter value from table
        function setFilterValue(filterType, value) {
            let filterInputId;
            switch(filterType) {
                case 'query':
                    filterInputId = 'queryFilter';
                    break;
                case 'hostname':
                    filterInputId = 'hostnameFilter';
                    break;
                default:
                    filterInputId = 'processFilter';
            }
            document.getElementById(filterInputId).value = value;
            applyFilters();
        }

        // Execute diagnostic query
        async function executeDiagnosticQuery(query, queryIndex) {
            const connectionString = document.getElementById('connectionStringInput').value.trim();
            
            if (!connectionString) {
                alert('Connection string is required. Please fill in the connection string at the top of the page.');
                return;
            }

            const resultDiv = document.getElementById(`result-${queryIndex}`);
            resultDiv.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; margin: 10px auto;"></div><p>Executing query...</p>';
            resultDiv.style.display = 'block';

            try {
                const response = await fetch('/api/deadlock/execute-diagnostic-query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        connectionString: connectionString,
                        query: query.replace(/\\n/g, '\n').replace(/\\'/g, "'"),
                        timeoutSeconds: 30
                    }),
                });

                const result = await response.json();

                if (!response.ok || !result.success) {
                    throw new Error(result.message || 'Failed to execute query');
                }

                // Display results
                let resultHtml = `<h5>Query Results (${result.recordCount} rows, ${result.executionTimeMs.toFixed(2)}ms)</h5>`;
                
                if (result.results && result.results.length > 0) {
                    resultHtml += '<table>';
                    
                    // Header
                    resultHtml += '<thead><tr>';
                    result.columnNames.forEach(col => {
                        resultHtml += `<th>${col}</th>`;
                    });
                    resultHtml += '</tr></thead>';
                    
                    // Data rows
                    resultHtml += '<tbody>';
                    result.results.forEach(row => {
                        resultHtml += '<tr>';
                        result.columnNames.forEach(col => {
                            const value = row[col];
                            resultHtml += `<td>${value !== null && value !== undefined ? value : 'NULL'}</td>`;
                        });
                        resultHtml += '</tr>';
                    });
                    resultHtml += '</tbody></table>';
                } else {
                    resultHtml += '<p>No results returned.</p>';
                }

                resultDiv.innerHTML = resultHtml;

            } catch (error) {
                console.error('Error executing diagnostic query:', error);
                resultDiv.innerHTML = `<div style="color: var(--danger); padding: 10px; background: var(--bg-primary); border-radius: 5px;">
                    <strong>Error:</strong> ${error.message}
                </div>`;
            }
        }

        // Load predefined queries
        async function loadPredefinedQueries() {
            const container = document.getElementById('predefinedQueries');
            container.innerHTML = '<div class="spinner" style="width: 20px; height: 20px; margin: 10px auto;"></div><p>Loading predefined queries...</p>';

            try {
                const response = await fetch('/api/deadlock/predefined-queries');
                const queries = await response.json();

                if (!response.ok) {
                    throw new Error('Failed to load predefined queries');
                }

                let html = '<div class="accordion">';
                queries.forEach((query, index) => {
                    html += `
                        <div class="accordion-item">
                            <div class="accordion-header" onclick="toggleAccordion('predefined-${index}')">
                                <span><strong>${query.name}</strong> - ${query.description}</span>
                                <span>‚ñº</span>
                            </div>
                            <div class="accordion-content" id="accordion-predefined-${index}">
                                <div class="code-block" style="margin-bottom: 10px;">${query.query}</div>
                                <button class="btn" onclick="executePredefinedQuery('${query.query.replace(/'/g, "\\'").replace(/\n/g, '\\n')}', 'predefined-${index}')">‚ñ∂Ô∏è Execute Query</button>
                                <div id="result-predefined-${index}" class="diagnostic-result" style="display: none; margin-top: 10px;"></div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';

                container.innerHTML = html;

            } catch (error) {
                console.error('Error loading predefined queries:', error);
                container.innerHTML = `<div style="color: var(--danger); padding: 10px;">
                    <strong>Error:</strong> ${error.message}
                </div>`;
            }
        }

        // Execute predefined query
        async function executePredefinedQuery(query, queryId) {
            return await executeDiagnosticQuery(query, queryId);
        }

    </script>
</body>
</html>
